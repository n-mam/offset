#ifndef VHD_HPP
#define VHD_HPP

#include <fxc/vd/DynVHD>
#include <fxc/rct/rct>

#include <string>

namespace fxc {

//create base parent vhd from a volume/snapshot block device 
void create_base_vhd(const std::wstring& volume, const std::wstring& file, fxc::TProgressCallback cbk)
{
  auto source = npl::make_file(volume, false);

  assert(source);

  auto nvdb = osl::GetNTFSVolumeData(source->iFDsync);

  uint64_t length = osl::GetBlockDeviceLength(source->iFDsync);

  LOG << "source volume length " << length;

  auto disk = std::make_shared<CDynamicVHD>(length, _2M);

  auto bs = disk->GetBlockSize();

  auto _buf = std::make_unique<uint8_t []>(bs);

  auto target = npl::make_file(file, true);

  // footer
  target->WriteSync((uint8_t *) &(disk->iFooter), sizeof(VHD_DISK_FOOTER), 0);

  // sparse header
  target->WriteSync((uint8_t *) &(disk->iHeader), sizeof(VHD_SPARSE_HEADER), sizeof(VHD_DISK_FOOTER));

  // pre-compute the BAT
  auto bat = std::make_unique<uint32_t []>(disk->iBATSize / sizeof(uint32_t));

  memset(bat.get(), 0xFF, disk->iBATSize);

  // MBR block's BAT entry
  osl::LTOB32(disk->FirstDataBlockOffset() / 512, (unsigned char *) (bat.get() + 0));

  uint64_t batIndex = 1;
  uint64_t validBATEntryCount = 1;

  auto blockInUse = false;

  auto bitmap = osl::GetVolumeInUseBitmap(source->iFDsync);

  for (int64_t i = 1; i <= nvdb.TotalClusters.QuadPart; i++)
  {
    if (bitmap->Buffer[(i - 1) / 8])
    {
      blockInUse = true;
    }

    if (((i * nvdb.BytesPerCluster) % bs == 0) || (i == nvdb.TotalClusters.QuadPart))
    {
      if (blockInUse)
      {
        uint64_t blockFileOffset = disk->FirstDataBlockOffset() + (validBATEntryCount * (512 + bs));
        osl::LTOB32(blockFileOffset / 512, (unsigned char *) (bat.get() + batIndex));
        blockInUse = false;
        validBATEntryCount++;
      }
      batIndex++;
    }
  }

  uint64_t totalClusterLength = nvdb.TotalClusters.QuadPart * nvdb.BytesPerCluster;

  LOG << "source volume total cluster length " << totalClusterLength;

  uint64_t pendinglen = length - totalClusterLength;

  LOG << "source volume pending length " << pendinglen;

  if (pendinglen)
  {
    uint64_t pendingoff = bs + totalClusterLength;

    auto fragments = CBaseDisk::LogicalToDataBlock(pendingoff, pendinglen, bs);

    for (auto& f : fragments)
    {
      batIndex = f.offset / bs;

      uint32_t batentry = osl::endian_reverse(*(bat.get() + batIndex));

      if (batentry == ~((uint32_t)0))
      {
        LOG << "setting BAT entry for pending len at " << batIndex;
        uint64_t blockFileOffset = disk->FirstDataBlockOffset() + (validBATEntryCount * (512 + bs));
        osl::LTOB32(blockFileOffset / 512, (unsigned char *) (bat.get() + batIndex));
        validBATEntryCount++;
      }
    }
  }

  LOG << "BAT constructed with " << validBATEntryCount
     << " block entries, last BAT index " << batIndex;

  uint64_t nTotalPayloadBlocks = validBATEntryCount;

  // bat
  target->WriteSync((uint8_t *) bat.get(), disk->iBATSize, sizeof(VHD_FOOTER_HEADER));

  // set target for io operations on disk 
  target->AddEventListener(disk);

  // MBR block
  disk->WriteSync((uint8_t *) &(disk->iMBR), sizeof(MBR), 0);

  nTotalPayloadBlocks--;

  bool stop = false;

  // payload blocks

  for (uint64_t index = 1; index < disk->GetTotalBATEntries() && !stop; index++)
  {
    uint32_t entry = osl::endian_reverse(*(bat.get() + index));

    if (entry != ~((uint32_t)0))
    {
      uint64_t len = bs;

      uint64_t off = bs * (index - 1);

      if ((off + bs) > length)
      {
        len = length % bs;
      }

      // read the source device
      auto fRet = source->ReadSync(_buf.get(), len, off);

      assert(fRet == len);

      // disk level write of volume level data block
      fRet = disk->WriteSync(_buf.get(), len, off + disk->GetPartitionStartOffset(0));

      assert(fRet == len);

      assert(bat[index] == disk->iBAT[index]);

      nTotalPayloadBlocks--;

      if (cbk)
      {
        stop = cbk(volume, (1.00 - ((float)nTotalPayloadBlocks/(float)validBATEntryCount)) * 100);
      }
    }
  }

  if (stop)
  {
    LOG << "create_base_vhd stop true";
    return;
  }

  assert(nTotalPayloadBlocks == 0);

  // assert the fact that constructed bat matches the one 
  // which is dynamically maintained due to disk level writes
  if (memcmp(disk->iBAT.get(), bat.get(), disk->iBATSize))
  {
    //DumpData("cbat.bin", (uint8_t *) bat.get(), disk->iBATSize);
    //DumpData("rbat.bin", (uint8_t *) disk->iBAT.get(), disk->iBATSize);
    LOG << "constructed bat does not match runtime bat";
  }

  // footer
  target->WriteSync(
    (uint8_t *) &(disk->iFooter),
    sizeof(VHD_DISK_FOOTER),
    disk->FirstDataBlockOffset() + (disk->iBlockCount * (512 + bs))
  );

  LOG << L" " << file << L" created";
}

//create differencing child vhd using either RCT CBT ranges (disk level) or volume level CBT
bool create_child_vhd(const std::wstring& source, const std::wstring& parent, const std::wstring& child, const std::wstring rctid)
{
  auto base = std::make_shared<CDynamicVHD>(parent);

  auto diff = std::make_shared<CDynamicVHD>(base.get());

  auto target = npl::make_file(child, true);

  auto fsBasePath = base->iPath;

  base.reset();

  // footer
  target->WriteSync((uint8_t *) &(diff->iFooter), sizeof(VHD_DISK_FOOTER), 0);

  // sparse header
  target->WriteSync((uint8_t *) &(diff->iHeader), sizeof(VHD_SPARSE_HEADER), sizeof(VHD_DISK_FOOTER));

  // parent locator 1
  uint8_t pl[PLDataSpaceSize] = { 0 };
  memmove(pl, fsBasePath.wstring().c_str(), fsBasePath.wstring().size() * sizeof(wchar_t));
  target->WriteSync(pl, PLDataSpaceSize, sizeof(VHD_FOOTER_HEADER));

  // parent locator 2
  memset(pl, 0, PLDataSpaceSize);
  std::wstring ru = L".\\" + fsBasePath.filename().wstring();
  memmove(pl, ru.c_str(), ru.size() * sizeof(wchar_t));
  target->WriteSync(pl, PLDataSpaceSize, sizeof(VHD_FOOTER_HEADER) + PLDataSpaceSize);

  // pre-compute the BAT
  auto bat = std::make_unique<uint32_t []>(diff->iBATSize / sizeof(uint32_t));
  memset(bat.get(), 0xFF, diff->iBATSize);

  auto bs = diff->GetBlockSize();

  auto dbiomap = fxc::ResilientChangeTrackingToDataBlockIO(source, rctid, bs);

  uint64_t blockCount = 0;

  for (auto& kv : dbiomap)
  {
    uint64_t fileoff = diff->FirstDataBlockOffset() + (blockCount * (512 + bs));
    osl::LTOB32(fileoff / 512, (unsigned char *) (bat.get() + kv.first));
    blockCount++;
  }

  // BAT
  target->WriteSync((uint8_t *) bat.get(), diff->iBATSize, sizeof(VHD_FOOTER_HEADER) + (2 * PLDataSpaceSize));

  auto hvhd = osl::AttachVHD(source);

  if (hvhd == INVALID_HANDLE_VALUE)
  {
    LOG << "create_child_vhd failed to attach vhd";
    return false; 
  }

  auto phyDiskPath = osl::GetPhysicalDiskPath(hvhd);

  if (!phyDiskPath.size())
  {
    LOG << "create_child_vhd failed to get physical disk object";
    return false; 
  }

  auto phyDisk = npl::make_file(phyDiskPath);

  // incremental data blocks
  auto _buf = std::make_unique<uint8_t []>(512 + bs);

  blockCount = 0;

  for (auto& kv : dbiomap)
  {
    LOG << "BAT index : " << kv.first;

    memset(_buf.get(), 0, 512 + bs);

    for (auto& dbio : kv.second)
    {
      LOG << "off : " << dbio.offset << " len : " << dbio.length;

      auto blockoff = dbio.offset % bs;

      CDynamicVHD::SetSectorBitmap(_buf.get(), blockoff, dbio.length, bs);

      auto fRet = phyDisk->ReadSync(_buf.get() + 512 + blockoff, dbio.length, dbio.offset);
    }

    target->WriteSync(
      (uint8_t *) _buf.get(),
      512 + bs,
      diff->FirstDataBlockOffset() + (blockCount * (512 + bs))
    );

    blockCount++;
  }

  osl::DllHelper virtDiskAPI("virtdisk.dll");

  auto pfnDetachVirtualDisk = (decltype(DetachVirtualDisk) *) virtDiskAPI["DetachVirtualDisk"];

  if (pfnDetachVirtualDisk == NULL)
  {
    LOG << "Failed to get pointer to DetachVirtualDisk " << GetLastError();
    return false;
  }

  pfnDetachVirtualDisk(hvhd, DETACH_VIRTUAL_DISK_FLAG_NONE, 0);

  // footer
  target->WriteSync(
    (uint8_t *) &(diff->iFooter),
    sizeof(VHD_DISK_FOOTER),
    diff->FirstDataBlockOffset() + (blockCount * (512 + bs))
  );

  return true;
}

//image copy from device(voume/disk) to file
bool create_raw_image(const std::wstring& device, const std::wstring& file, TProgressCallback cbk, uint64_t o = 0)
{
  auto source = npl::make_file(device, false);

  auto target = npl::make_file(file, true);

  if (!osl::AllowExtendedDasdIO(source->iFDsync))
  {
    LOG << "AllowExtendedDasdIO failed, error : " << GetLastError();
  }

  auto length = osl::GetBlockDeviceLength(source->iFDsync);

  LOG << "Total length " << length;

  DWORD dwBytesRead = 0;
  DWORD dwBytesWritten = 0;
  uint64_t totalBytesRead = 0;
  uint64_t totalBytesWritten = 0;

  bool stop = false;

  LARGE_INTEGER offset;
  offset.QuadPart = o;

  uint64_t pendingBytes = length, toRead = 0;

  auto buffer = std::make_unique<char []>(_2M);

  while (!stop && pendingBytes)
  {
    if (pendingBytes >= _2M)
    {
      toRead = _2M;
    }
    else
    {
      toRead = (DWORD)(pendingBytes + ((pendingBytes % 512) ? (512 - (pendingBytes % 512)) : 0));
    }

    // read the source device
    dwBytesRead = source->ReadSync((uint8_t *) buffer.get(), toRead, offset.QuadPart);

    // write to the target file
    dwBytesWritten = target->WriteSync((uint8_t *) buffer.get(), dwBytesRead, offset.QuadPart);

    assert(dwBytesWritten == dwBytesRead);

    totalBytesRead += dwBytesRead;

    totalBytesWritten += dwBytesWritten;

    pendingBytes -= dwBytesRead;

    offset.QuadPart += _2M;

    if (cbk)
    {
      stop = cbk(device, static_cast<int>(((double)totalBytesRead/(double)length) * 100));
    }
  }

  LOG << "Read " << totalBytesRead << " bytes";
  LOG << "Wrote " << totalBytesWritten << " bytes";

  return true;
}

} //namespace fxc

#endif