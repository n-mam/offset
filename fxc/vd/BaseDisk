#ifndef BASEDISK_HPP
#define BASEDISK_HPP

#include <ctime>
#include <tuple>
#include <vector>
#include <string>
#include <memory>
#include <cinttypes>
#include <filesystem>

#include <fxc/vd/formats>

namespace fxc {

struct DataBlockIO
{
  const uint8_t *buffer = nullptr;
  uint64_t offset = 0;
  size_t length = 0;
};

using TProgressCallback = std::function<bool (std::wstring, int)>;

class BaseDisk : public npl::Subject<uint8_t, uint8_t>
{
  public:

  MBR iMBR = { 0 };

  std::filesystem::path iPath;

  npl::SPSubject<uint8_t, uint8_t> iFile = nullptr;

  std::unique_ptr<uint8_t []> iPayloadBlock = nullptr;

  public:

  using SPBaseDisk = std::shared_ptr<BaseDisk>;

  BaseDisk() {}

  // new virtual disk abstraction
  BaseDisk(uint64_t size, uint32_t blocksize)
  {
    if (size < _2T)
    {
      InitializeMBR(size, blocksize / 512);
    }
    else
    {
      InitializeGPT(size, blocksize / 512);
    }
  }

  // existing virtual disk abstraction
  BaseDisk(const std::wstring& path, uint32_t len)
  {
    iPath = path;
    iFile = npl::make_file(iPath);
    iRawSectors = std::make_unique<uint8_t []>(len);
    iFile->ReadSync(iRawSectors.get(), len, 0);
  }

  virtual ~BaseDisk()
  {
    if (iFile)
    {
      iFile->GetDispatcher()->RemoveEventListener(iFile);
    }
  }

  virtual bool IsFixed() = 0;

  virtual bool IsDynamic() = 0;

  virtual bool IsDifferencing() = 0;

  virtual uint32_t GetBlockSize() = 0;

  virtual uint64_t GetLogicalDiskLength() = 0;

  virtual std::vector<std::wstring> GetParentLocators(void) = 0;

  virtual SPBaseDisk GetBaseParent(void)
  {
    auto base = std::dynamic_pointer_cast<BaseDisk>(shared_from_this());

    while (base->iParent)
    {
      base = base->iParent;
    }

    return base;
  }

  virtual uint64_t GetPartitionStartOffset(int n)
  {
    return iMBR.partitions[n].start_sector * 512;
  }

  virtual uint64_t GetPartitionLength(int n)
  {
    return iMBR.partitions[n].total_sectors * 512ULL;
  }

  virtual int32_t ReadSync(const uint8_t *b, size_t l, uint64_t o) override
  {
    uint64_t delta = 0;
    size_t nBytesRead = 0;

    auto fragments = LogicalToDataBlock(o, l, GetBlockSize());

    memset((void *)b, 0 ,l );

    for (auto& f : fragments)
    {
      f.buffer = b + delta;

      auto level = GetBaseParent();

      while (level)
      {
        auto fRet = level->DataBlockRead(f);

        assert(fRet == f.length);

        level = level->iChild;
      }

      nBytesRead += f.length;

      delta += f.length;
    }

    return static_cast<int32_t>(nBytesRead);
  }

  virtual int32_t WriteSync(const uint8_t *b, size_t l, uint64_t o) override
  {
    uint64_t delta = 0;
    size_t nBytesWritten = 0;

    auto fragments = LogicalToDataBlock(o, l, GetBlockSize());

    for (auto& f : fragments)
    {
      f.buffer = b + delta;

      auto fRet = this->DataBlockWrite(f);

      assert(fRet == f.length);

      nBytesWritten += f.length;

      delta += f.length;
    }

    return static_cast<int32_t>(nBytesWritten);
  }

  static std::vector<DataBlockIO> LogicalToDataBlock(uint64_t off, size_t len, uint32_t bs)
  {
    size_t done = 0;
    size_t pending = len;

    uint64_t chunk_off = 0;
    size_t chunk_len = 0;

    std::vector<DataBlockIO> fragments;

    while (done != len)
    {
      chunk_off = (off + done) % bs;
      chunk_len = (chunk_off + pending > bs) ? (bs - chunk_off) : pending;
      fragments.push_back({nullptr, off + done, chunk_len});
      done += chunk_len;
      pending = len - done;
    }

    return fragments;
  }

  virtual void Initialize(void)
  {
    if(iFile)
    {
      iFile->AddEventListener(shared_from_this());
      ReadSync((uint8_t *) &iMBR, sizeof(MBR), 0);
    }
  }

  virtual void DumpStructure(void)
    {
      LOG;
      LOG << "Master Boot Record : ";
      
      LOG << "DiskID                       : ";
      
      DumpBytes(iMBR.DiskID, 4, true);

      for (int i = 0; i < 4; i++)
      {
        LOG << "start_sector                 : " << iMBR.partitions[i].start_sector << " sector ";
        LOG << "total_sectors                : " << iMBR.partitions[i].total_sectors << " sector ";
        LOG << "------------------";
      }

      LOG << "signature                    : " << iMBR.signature; 
    }

  auto image_copy_from(npl::SPFileDevice source, SPBaseDisk target, uint64_t o = 0, TProgressCallback cbk =nullptr)
  {
    if (!osl::AllowExtendedDasdIO(source->iFDsync))
    {
      LOG << "AllowExtendedDasdIO failed, error : " << GetLastError();
    }

    auto length = osl::GetBlockDeviceLength(source->iFDsync);

    LOG << "Total length " << length;

    DWORD dwBytesRead = 0;
    DWORD dwBytesWritten = 0;
    uint64_t totalBytesRead = 0;
    uint64_t totalBytesWritten = 0;

    bool stop = false;

    LARGE_INTEGER r_offset, w_offset;
    r_offset.QuadPart = 0;
    w_offset.QuadPart = o;

    uint64_t bs = target->GetBlockSize();
    uint64_t pendingBytes = length, toRead = 0;

    auto buffer = std::make_unique<char []>(bs);

    while (!stop && pendingBytes)
    {
      if (pendingBytes >= bs)
      {
        toRead = bs;
      }
      else
      {
        toRead = (DWORD)(pendingBytes + ((pendingBytes % 512) ? (512 - (pendingBytes % 512)) : 0));
      }

      // read the source device
      dwBytesRead = source->ReadSync((uint8_t *) buffer.get(), toRead, r_offset.QuadPart);
      
      if (dwBytesRead == 0)
      {
        LOG << "break";
      }
      // write to the target disk
      dwBytesWritten = target->WriteSync((uint8_t *) buffer.get(), dwBytesRead, w_offset.QuadPart);

      assert(dwBytesWritten == dwBytesRead);

      totalBytesRead += dwBytesRead;

      totalBytesWritten += dwBytesWritten;

      pendingBytes -= dwBytesRead;

      r_offset.QuadPart += bs;
      w_offset.QuadPart += bs;

      dwBytesRead = dwBytesWritten = 0;

      if (cbk)
      {
        stop = cbk(L"", static_cast<int>(((double)totalBytesRead/(double)length) * 100));
      }
    }

    LOG << "Read " << totalBytesRead << " bytes";
    LOG << "Wrote " << totalBytesWritten << " bytes";

    return target;
  }

  protected:

  SPBaseDisk iParent = nullptr;

  SPBaseDisk iChild = nullptr;

  std::unique_ptr<uint8_t []> iRawSectors = nullptr;

  virtual size_t DataBlockRead(DataBlockIO& bio) = 0;

  virtual size_t DataBlockWrite(DataBlockIO& bio) = 0;

  void InitializeMBR(uint64_t size, uint32_t startSector)
  {
    /* signature */
    iMBR.signature = 0xAA55;

    /* diskid = current epoch */
    uint32_t epoch = static_cast<uint32_t>(std::time(nullptr));
    memmove(&(iMBR.DiskID), &epoch, 4);

      /* NTFS */
    iMBR.partitions[0].type = 0x07;

    /* blocksize alignment */
    iMBR.partitions[0].start_sector = startSector;

    /* total sectors in the partition(volume) */
    iMBR.partitions[0].total_sectors = static_cast<uint32_t>(size / 512);
  }

  void InitializeGPT(uint64_t size, uint32_t blocksize)
  {
    //todo
  }

};

using SPBaseDisk = std::shared_ptr<BaseDisk>;

} //namespace fxc

#endif