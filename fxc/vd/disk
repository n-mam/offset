#ifndef DISK_HPP
#define DISK_HPP

#include <ctime>
#include <tuple>
#include <vector>
#include <string>
#include <memory>
#include <cstdint>
#include <cinttypes>
#include <functional>
#include <filesystem>

#include <fxc/vd/formats>
#include <observer/subject>

#include <zlib.h>

namespace fxc {

struct DataBlockIO {
    size_t length = 0;
    uint64_t offset = 0;
    const uint8_t *buffer = nullptr;
};

struct disk : public npl::subject<uint8_t, uint8_t> {

    using spdisk = std::shared_ptr<disk>;

    MBR iMBR = { 0 };
    spdisk iChild = nullptr;
    spdisk iParent = nullptr;
    partition iPartitionType;
    std::filesystem::path iPath;
    GptHdrRev1 alignas(512) iGptHdr = { 0 };
    GPE alignas(512) iPartitions[4] = { 0 };

    npl::spsubject<uint8_t, uint8_t> iFile = nullptr;
    std::unique_ptr<uint8_t []> iRawSectors = nullptr;
    std::unique_ptr<uint8_t []> iPayloadBlock = nullptr;

    disk() {}
    // new virtual disk abstraction
    disk(uint64_t size, uint32_t blocksize, partition partitionType) {
        if (size >= _2T) {
            iPartitionType = partition::gpt;
        } else {
            iPartitionType = partitionType;
        }
        if (iPartitionType == partition::mbr) {
            initializeMBR(size, blocksize / 512);
        } else if (iPartitionType == partition::gpt) {
            initializeGPT(size, blocksize / 512);
        }
    }
    // existing virtual disk abstraction
    disk(const std::wstring& path, uint32_t len) {
        iPath = path;
        iFile = npl::make_file<std::wstring>(iPath);
        iRawSectors = std::make_unique<uint8_t []>(len);
        iFile->ReadSync(iRawSectors.get(), len, 0);
    }

    virtual ~disk() {
        if (iFile) {
            get_last_target(iFile)->RemoveEventListener(iFile);
        }
    }

    virtual bool isFixed() = 0;
    virtual bool isDynamic() = 0;
    virtual bool isDifferencing() = 0;
    virtual uint32_t getBlockSize() = 0;
    virtual uint64_t getLogicalDiskLength() = 0;
    virtual std::vector<std::wstring> getParentLocators(void) = 0;

    virtual spdisk getBaseParent(void) {
        auto base = std::dynamic_pointer_cast<disk>(shared_from_this());
        while (base->iParent) {
            base = base->iParent;
        }
        return base;
    }

    virtual uint64_t getPartitionLength(int n) {
        uint64_t length = 0;
        if (iPartitionType == partition::gpt) {
            length = (iPartitions[n].end_lba - iPartitions[n].start_lba) * 512ULL;
        }
        else if (iPartitionType == partition::mbr) {
            length = iMBR.partitions[n].total_sectors * 512ULL;
        }
        return length;
    }

    virtual uint64_t getPartitionStartOffset(int n) {
        uint64_t offset = 0;
        if (iPartitionType == partition::gpt) {
            offset = (iPartitions[n].start_lba) * 512ULL;
        } else if (iPartitionType == partition::mbr) {
            offset = iMBR.partitions[n].start_sector * 512ULL;
        }
        return offset;
    }

    auto commitPartitionTable() {
        uint8_t buf[512*5];
        //we are streaming
        memmove(buf, &iMBR, sizeof(MBR));
        if (iPartitionType == partition::gpt) {
            /*   0       1          2            3              4
             * [MBR] [GPT-Hdr] [Partitions] [GPT-Hdr(B)] [Partitions(B)]
             */
            memmove(buf + (512 * 1), &iGptHdr, sizeof(GptHdrRev1));
            memmove(buf + (512 * 2), iPartitions, 4 * sizeof(GPE));
            memmove(buf + (512 * 3), &iGptHdr, sizeof(GptHdrRev1));
            memmove(buf + (512 * 4), iPartitions, 4 * sizeof(GPE));
            // update relevant extries for backup GPT header
            ((GptHdrRev1 *)(buf + (512 * 3)))->u64LbaCurrent = (uint64_t) 3;
            ((GptHdrRev1 *)(buf + (512 * 3)))->u64LbaBackup = 1;
            ((GptHdrRev1 *)(buf + (512 * 3)))->u64LbaFirstPartitionEntry = (uint64_t) 4;
            // recompute crc32 for backup header
            unsigned long  crc = crc32(0L, Z_NULL, 0);
            crc = crc32(crc, (const unsigned char*)&iGptHdr, sizeof(GptHdrRev1));
            ((GptHdrRev1 *)(buf + (512 * 3)))->u32Crc = crc;
        }
        return WriteSync(buf, sizeof(buf), 0);
    }

    virtual int32_t ReadSync(const uint8_t *b, size_t l, uint64_t o) override {
        uint64_t delta = 0;
        size_t nBytesRead = 0;
        auto fragments = LogicalToDataBlock(o, l, getBlockSize());
        memset((void *)b, 0 ,l );
        for (auto& f: fragments) {
            f.buffer = b + delta;
            auto level = getBaseParent();
            while (level) {
                auto fRet = level->DataBlockRead(f);
                assert(fRet == f.length);
                level = level->iChild;
            }
            nBytesRead += f.length;
            delta += f.length;
        }
        return static_cast<int32_t>(nBytesRead);
    }

    virtual int32_t WriteSync(const uint8_t *b, size_t l, uint64_t o) override {
        uint64_t delta = 0;
        size_t nBytesWritten = 0;
        auto fragments = LogicalToDataBlock(o, l, getBlockSize());
        for (auto& f : fragments) {
            f.buffer = b + delta;
            auto fRet = this->DataBlockWrite(f);
            assert(fRet == f.length);
            nBytesWritten += f.length;
            delta += f.length;
        }
        return static_cast<int32_t>(nBytesWritten);
    }

    static std::vector<DataBlockIO> LogicalToDataBlock(uint64_t off, size_t len, uint32_t bs) {
        size_t done = 0;
        size_t pending = len;
        size_t chunk_len = 0;
        uint64_t chunk_off = 0;
        std::vector<DataBlockIO> fragments;
        while (done != len) {
            chunk_off = (off + done) % bs;
            chunk_len = (chunk_off + pending > bs) ? (bs - chunk_off) : pending;
            fragments.push_back({chunk_len, off + done, nullptr});
            done += chunk_len;
            pending = len - done;
        }
        return fragments;
    }

    template<typename T>
    void buildDifferencingChain(void) {
        auto parentLocators = getParentLocators();
        for (const auto& pl : parentLocators) {
            if (std::filesystem::exists(pl)) {
                iParent = std::make_shared<T>(pl);
                iParent->buildDifferencingChain<T>();
                iParent->iChild = std::dynamic_pointer_cast<disk>(shared_from_this());
                break;
            }
        }
        iFile->AddEventListener(shared_from_this());
    }

    virtual void dumpStructure(void) {
        LOG << "MBR partition table: ";
        LOG << " ------------------";
        for (int i = 0; i < 4; i++) {
            LOG << " type                         : " << (uint32_t)iMBR.partitions[i].type;
            LOG << " start_sector                 : " << iMBR.partitions[i].start_sector << " sector ";
            LOG << " total_sectors                : " << iMBR.partitions[i].total_sectors << " sector ";
            LOG << " ------------------";
        }
        if (iMBR.partitions[0].type == 0xEE) {
            LOG << "GUID partition table detected";
        } else {
            LOG << "MBR partition table detected";
            LOG << " DiskID                       : ";
            DumpBytes(iMBR.DiskID, 4, true);
            LOG << " signature                    : " << iMBR.signature;
        }
    }

    protected:

    virtual size_t DataBlockRead(DataBlockIO& bio) = 0;
    virtual size_t DataBlockWrite(DataBlockIO& bio) = 0;

    void initializeMBR(uint64_t size, uint32_t startSector) {
        /* signature */
        iMBR.signature = 0xAA55;
        /* diskid = current epoch */
        uint32_t epoch = static_cast<uint32_t>(std::time(nullptr));
        memmove(&(iMBR.DiskID), &epoch, 4);
        /* NTFS */
        iMBR.partitions[0].type = 0x07;
        /* blocksize alignment */
        iMBR.partitions[0].start_sector = startSector;
        /* total sectors in the partition(volume) */
        iMBR.partitions[0].total_sectors = static_cast<uint32_t>(size / 512);
    }

    void initializeGPT(uint64_t size, uint32_t startSector) {
        // MBR
        iMBR.signature = 0xAA55;
        /* diskid = current epoch */
        uint32_t epoch = static_cast<uint32_t>(std::time(nullptr));
        memmove(&(iMBR.DiskID), &epoch, 4);
        /* GPT */
        iMBR.partitions[0].type = 0xEE;
        /* LBA 1 */
        iMBR.partitions[0].start_sector = (uint32_t) 1;
        /* total sectors in the partition(volume) */
        iMBR.partitions[0].total_sectors = 0xFFFFFFFF;
        // Header
        memmove(&iGptHdr.abSignature, "EFI PART", strlen("EFI PART"));
        iGptHdr.u32Revision = 0x00010000;
        iGptHdr.cbHeader = sizeof (GptHdrRev1);
        /**
         *   0       1          2            3              4
         * [MBR] [GPT-Hdr] [Partitions] [GPT-Hdr(B)] [Partitions(B)]
         */
        iGptHdr.u64LbaCurrent = (uint64_t) 1;
        iGptHdr.u64LbaBackup = 3;
        iGptHdr.u64FirstUsableLbaForPartitions = (uint64_t) startSector;
        iGptHdr.u64LastUsableLbaForPartitions = ((uint64_t) startSector + (size / 512));

        GUID guid;
        CoCreateGuid(&guid);
        memmove(&iGptHdr.DiskUuid, &guid, sizeof(GUID));
        iGptHdr.u64LbaFirstPartitionEntry = (uint64_t) 2;
        iGptHdr.cPartitionEntries = (uint64_t) 4;
        iGptHdr.cbPartitionEntry = (uint64_t) sizeof(GPE);
        // partition entry
        // Basic data partition EBD0A0A2-B9E5-4433-87C0-68B6B72699C7
        iPartitions[0].type_guid[0] = 0xA2;
        iPartitions[0].type_guid[1] = 0xA0;
        iPartitions[0].type_guid[2] = 0xD0;
        iPartitions[0].type_guid[3] = 0xEB;
        iPartitions[0].type_guid[4] = 0xE5;
        iPartitions[0].type_guid[5] = 0xB9;
        iPartitions[0].type_guid[6] = 0x33;
        iPartitions[0].type_guid[7] = 0x44;
        iPartitions[0].type_guid[8] = 0x87;
        iPartitions[0].type_guid[9] = 0xC0;
        iPartitions[0].type_guid[10] = 0x68;
        iPartitions[0].type_guid[11] = 0xB6;
        iPartitions[0].type_guid[12] = 0xB7;
        iPartitions[0].type_guid[13] = 0x26;
        iPartitions[0].type_guid[14] = 0x99;
        iPartitions[0].type_guid[15] = 0xC7;

        GUID guid1;
        CoCreateGuid(&guid1);
        memmove(&iPartitions[0].guid, &guid1, sizeof(GUID));
        iPartitions[0].start_lba = (uint64_t) startSector;
        iPartitions[0].end_lba = ((uint64_t) startSector + (size / 512));
        unsigned long  crc = crc32(0L, Z_NULL, 0);
        crc = crc32(crc, (const unsigned char*)iPartitions, sizeof(GPE) * 4);
        iGptHdr.u32CrcPartitionEntries = crc;
        crc = crc32(0L, Z_NULL, 0);
        crc = crc32(crc, (const unsigned char*)&iGptHdr, sizeof(GptHdrRev1));
        iGptHdr.u32Crc = crc;
    }
};

using spdisk = std::shared_ptr<disk>;

} //namespace fxc

#endif