#ifndef SS_HPP
#define SS_HPP

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>

#include <map>
#include <tuple>
#include <string>
#include <iostream>
#include <functional>
#include <filesystem>

namespace fxc {

bool bCoInitializedSecurity = false;
thread_local bool bCoInitialized = false;
HANDLE g_writerQuitEvent = INVALID_HANDLE_VALUE;

using TSnapshotSet = std::vector<
  std::tuple<std::wstring, std::wstring, std::wstring>>;

using TSnapshotCBK = std::function<void (TSnapshotSet)>;

auto AsyncWait(IVssAsync **async) -> HRESULT {
    HRESULT hr = (*async)->Wait();
    if (hr != S_OK) {
        LOG << "Wait failed " << std::hex << hr;
        return hr;
    }
    HRESULT status;
    hr = (*async)->QueryStatus(&status, NULL);
    if ((hr != S_OK) && (status != VSS_S_ASYNC_FINISHED)) {
        LOG << "QueryStatus failed " << std::hex << hr;
    }
    (*async)->Release(), (*async) = nullptr;
    return hr;
}

auto InitializeCOM(void) -> HRESULT {
    if (bCoInitialized) return S_OK;
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (!bCoInitializedSecurity) {
        CHKCOM(hr = CoInitializeSecurity(
                        NULL,
                        -1,
                        NULL,
                        NULL,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        EOAC_NONE,
                        NULL))
        bCoInitializedSecurity = true;
    }
    _end:
    bCoInitialized = (hr == S_OK);
    return hr;
}

auto InitializeBackupComponent(IVssBackupComponents **bc, bool bForRestore = true, BSTR document = NULL) -> HRESULT {
    HRESULT hr = CreateVssBackupComponents(bc);
    if (hr != S_OK) {
        LOG << "CreateVssBackupComponents failed " << std::hex << hr;
        goto end;
    }
    if (bForRestore) {
        hr = (*bc)->InitializeForRestore(document);
    } else {
        hr = (*bc)->InitializeForBackup();
    }
    if (hr != S_OK) {
        LOG << "InitializeFor" << (bForRestore ? "Restore" : "Backup") << " failed " << std::hex << hr;
    }
    end:
    return hr;
}

auto IsVolumeSupported(const std::wstring& volumePath) -> bool {
    HRESULT hr;
    BOOL bSupported = FALSE;
    fxc::InitializeCOM();
    IVssBackupComponents *pBC = nullptr;
    CHKCOM(hr = InitializeBackupComponent(&pBC, false, nullptr))
    CHKCOM(hr = pBC->IsVolumeSupported(GUID_NULL, (wchar_t *)volumePath.c_str(), &bSupported))
    _end:
    if (pBC) pBC->Release();
    return bSupported;
}

auto CreateSnapshot(const std::vector<std::wstring>& volumes, TSnapshotCBK cbk = nullptr) -> bool {
    HRESULT hr = 0;
    HRESULT qhr = 0;
    TSnapshotSet ss;
    VSS_ID m_snap[64] = { 0 };
    IVssAsync *pAS = nullptr;
    IVssBackupComponents *pBC = nullptr;
    fxc::InitializeCOM();
    STATUS(0) << "Creating backup component..";
    CHKCOM(hr = InitializeBackupComponent(&pBC, false, nullptr))
    CHKCOM(hr = pBC->SetBackupState(FALSE, TRUE, VSS_BT_FULL, FALSE))
    STATUS(0) << "Gather writer metadata..";
    CHKCOM(hr = pBC->GatherWriterMetadata(&pAS))
    CHKCOM(hr = AsyncWait(&pAS))
    STATUS(0) << "StartSnapshotSet..";
    VSS_ID m_set;
    CHKCOM(hr = pBC->StartSnapshotSet(&m_set))
    for (int i = 0; i < volumes.size(); i++) {
        CHKCOM(hr = pBC->AddToSnapshotSet(
            (wchar_t *)volumes[i].c_str(),
            GUID_NULL,
            &m_snap[i]))
    }
    STATUS(0) << "PrepareForBackup..";
    CHKCOM(hr = pBC->PrepareForBackup(&pAS))
    CHKCOM(hr = AsyncWait(&pAS))
    STATUS(0) << "DoSnapshotSet..";
    CHKCOM(hr = pBC->DoSnapshotSet(&pAS))
    CHKCOM(hr = AsyncWait(&pAS))
    for (int i = 0; i < 64; i++) {
        if (m_snap[i] != GUID_NULL) {
            VSS_SNAPSHOT_PROP m_prop = {0};
            CHKCOM(hr = pBC->GetSnapshotProperties(m_snap[i], &m_prop))
            ss.push_back({
                volumes[i],
                m_prop.m_pwszSnapshotDeviceObject,
                m_prop.m_pwszOriginalVolumeName});
        }
    }
    if (cbk) {
        cbk(ss);
    }
    STATUS(0) << "BackupComplete..";
    CHKCOM(hr = pBC->BackupComplete(&pAS))
    CHKCOM(hr = AsyncWait(&pAS))

    _end:
    if (pAS) pAS->Release();
    if (pBC) pBC->Release();
    return (hr == S_OK && qhr == VSS_S_ASYNC_FINISHED);
}

auto EnumerateSnapshots() {
    HRESULT hr;
    VSS_OBJECT_PROP Prop;
    std::vector<std::tuple<std::wstring, std::wstring>> ss;
    fxc::InitializeCOM();
    IVssEnumObject *pIEnumSnapshots = nullptr;
    IVssBackupComponents *pBC = nullptr;
    CHKCOM(hr = InitializeBackupComponent(&pBC, false, nullptr))
    CHKCOM(hr = pBC->SetContext(VSS_CTX_ALL))
    CHKCOM(hr = pBC->SetBackupState(FALSE, TRUE, VSS_BT_FULL, FALSE))
    CHKCOM(hr = pBC->Query(
        GUID_NULL,
        VSS_OBJECT_NONE,
        VSS_OBJECT_SNAPSHOT,
        &pIEnumSnapshots))
    while(true) {
        ULONG ulFetched;
        VSS_SNAPSHOT_PROP& Snap = Prop.Obj.Snap;
        hr = pIEnumSnapshots->Next(1, &Prop, &ulFetched);
        if (ulFetched == 0)
            break;
        ss.push_back({
            Snap.m_pwszSnapshotDeviceObject,
            Snap.m_pwszOriginalVolumeName});
        VssFreeSnapshotProperties(&Snap);
    }
    _end:
    return ss;
}

auto testSnapshot(std::vector<std::wstring> volumes) {
    fxc::EnumerateSnapshots();
    std::vector<std::wstring> supported, unsupported;
    for (const auto& volume : volumes) {
        if (fxc::IsVolumeSupported(volume)) {
            supported.push_back(volume);
        } else {
            LOG << " excluding unsupported volume : " << volume;
        }
    }
    fxc::CreateSnapshot(
        supported,
        [] (fxc::TSnapshotSet ss) {
            for (auto& s : ss) {
                auto [volume, snapshotDevice, volumeDevice] = s;
                LOG << " " << volume << " " << snapshotDevice << " " << volumeDevice;
            }
        });
}

// {E9B8079B-248F-454F-ADE0-38A51E568335}
static const GUID FxcWriterId =
{ 0xe9b8079b, 0x248f, 0x454f, { 0xad, 0xe0, 0x38, 0xa5, 0x1e, 0x56, 0x83, 0x35 } };

static const wchar_t* const FxcWriterName = L"FXCWriter";

std::map<std::wstring, std::vector<std::wstring>> g_excludeList;

struct FxcWriter : public CVssWriter {

    FxcWriter() {}

    virtual ~FxcWriter() {
        Uninitialize();
    }

    HRESULT STDMETHODCALLTYPE Initialize() {
        HRESULT hr = CVssWriter::Initialize(
                        FxcWriterId,     // WriterID
                        FxcWriterName, 	 // wszWriterName
                        VSS_UT_USERDATA, // ut
                        VSS_ST_OTHER);   // st
        if (FAILED(hr)) {
            LOG << L"CVssWriter::Initialize failed";
            return hr;
        }
        hr = Subscribe();
        if (FAILED(hr)) {
            LOG << L"CVssWriter::Subscribe failed";
        }
        return hr;
    }
    HRESULT STDMETHODCALLTYPE Uninitialize() {
        return Unsubscribe();
    }
    // OnIdentify is called as a result of the requestor calling GatherWriterMetadata
    bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata) {
        LOG << "OnIdentify";
        return true;
    }
    // This function is called as a result of the requestor calling PrepareForBackup
    // this indicates to the writer that a backup sequence is being initiated
    bool STDMETHODCALLTYPE OnPrepareBackup(_In_ IVssWriterComponents*) {
        LOG << "writer OnPrepareBackup";
        return true;
    }
    // This function is called after a requestor calls DoSnapshotSet
    // time-consuming actions related to Freeze can be performed here
    bool STDMETHODCALLTYPE OnPrepareSnapshot() {
        LOG << "writer OnPrepareSnapshot";
        return true;
    }
    // This function is called after a requestor calls DoSnapshotSet
    // here the writer is expected to freeze its store
    bool STDMETHODCALLTYPE OnFreeze() {
        LOG << "Writer OnFreeze";
        return true;
    }
    // This function is called after a requestor calls DoSnapshotSet
    // here the writer is expected to thaw its store
    bool STDMETHODCALLTYPE OnThaw() {
        LOG << "writer OnThaw";
        return true;
    }
    // This function is called after a requestor calls DoSnapshotSet
    bool STDMETHODCALLTYPE OnPostSnapshot(_In_ IVssWriterComponents*) {
        LOG << "writer OnPostSnapshot";
        auto originalVolumeNames = CVssWriter::GetCurrentVolumeArray();
        auto nVolumesInSnapshotSet = CVssWriter::GetCurrentVolumeCount();
        for (uint32_t i = 0; i < nVolumesInSnapshotSet; i++) {
            LPCWSTR pwszSnapshotDevice = nullptr;
            auto originalVolume = originalVolumeNames[i];
            auto hr = CVssWriter::GetSnapshotDeviceName(originalVolume, &pwszSnapshotDevice);
            if (hr == S_OK) {
                LOG << L"OnPostSnapshot " << originalVolume << L" " << pwszSnapshotDevice;
                auto excludeList = g_excludeList[originalVolume];
                auto tokens = osl::split<std::wstring>(pwszSnapshotDevice, L"GLOBALROOT\\Device\\");
                auto snapshotRoot = tokens[0] + tokens[1];
                for (const auto& file : excludeList) {
                    std::filesystem::path originalPath = file;
                    auto snapshotFilePath = snapshotRoot + L"\\" + originalPath.relative_path().wstring();
                    LOG << L"OnPostSnapshot " <<  file << L" -> " << snapshotFilePath;
                    auto rc = DeleteFileW(snapshotFilePath.c_str());
                    if (rc) {
                        STATUS(0) << "OnPostSnapshot successfully deleted file " << snapshotFilePath;
                    } else {
                        STATUS(0) << "OnPostSnapshot failed to delete file " << snapshotFilePath << GetLastError();
                    }
                }
            }
        }
        g_excludeList.clear();
        return true;
    }
    // This function is called to abort the writer's backup sequence.
    // This should only be called between OnPrepareBackup and OnPostSnapshot
    bool STDMETHODCALLTYPE OnAbort() {
        LOG << "OnAbort";
        return true;
    }
    // This function is called as a result of the requestor calling BackupComplete
    bool STDMETHODCALLTYPE OnBackupComplete(_In_ IVssWriterComponents*) {
        LOG << "OnBackupComplete";
        return true;
    }
    // This function is called at the end of the backup process.  This may happen as a result
    // of the requestor shutting down, or it may happen as a result of abnormal termination
    // of the requestor.
    bool STDMETHODCALLTYPE OnBackupShutdown(_In_ VSS_ID) {
        LOG << "OnBackupShutdown";
        return true;
    }
    // This function is called as a result of the requestor calling PreRestore
    // This will be called immediately before files are restored
    bool STDMETHODCALLTYPE OnPreRestore(_In_ IVssWriterComponents *) {
        LOG << "OnPreRestore";
        return true;
    }
    // This function is called as a result of the requestor calling PreRestore
    // This will be called immediately after files are restored
    bool STDMETHODCALLTYPE OnPostRestore(_In_ IVssWriterComponents*) {
        LOG << "OnPostRestore";
        return true;
    }
};

auto excludeListWriterThread(void) {
    fxc::InitializeCOM();
    FxcWriter writer;
    auto hr = writer.Initialize();
    if (FAILED(hr)) {
        ERR << L"writer.Initialize failed" << hr;
        return;
    }
    g_writerQuitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    auto rc = WaitForSingleObject(g_writerQuitEvent, INFINITE);
    if(rc != WAIT_OBJECT_0) {
        LOG << L"WaitForSingleObject failed " << GetLastError();
        return;
    }
    LOG << "Writer exiting";
    CloseHandle(g_writerQuitEvent);
    g_writerQuitEvent = INVALID_HANDLE_VALUE;
    writer.Uninitialize();
}

auto startExcludeListWriterThread(void) {
    std::thread(excludeListWriterThread).detach();
}

auto stopExcludeListWriterThread(void) {
    if (g_writerQuitEvent != INVALID_HANDLE_VALUE) {
        SetEvent(g_writerQuitEvent);
    }
}

auto updateVolumeExludePathsForSnapshot(const std::wstring volume, const std::vector<std::wstring>& excludeList) {
    g_excludeList[volume] = excludeList;
}

} //namespace fxc

#endif