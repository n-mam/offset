#ifndef FXC_HPP
#define FXC_HPP

#include <future>
#include <iostream>

#include <npl/npl>
#include <protocol/ftp>

#include <fxc/vd/vd>
#include <fxc/ss/ss>
#include <fxc/rct/rct>

namespace fxc {

struct TBackupConfig {
    std::wstring m_volume;
    std::wstring m_level;
    std::wstring m_format;
    std::wstring m_destination;
    std::vector<std::wstring> m_exclude;
    bool m_live;
};

struct TMountConfig {
    bool m_mode;
    uint8_t m_write;
    bool m_encrypt;
    wchar_t m_drive;
    int m_partition;
    uint64_t m_size;
    std::wstring m_file;
};

auto getExtentionForFormat(const std::wstring& format) {
    if (format == L"d-vhd")
        return L"d.vhd";
    else if (format == L"f-vhd")
        return L"f.vhd";
    else if (format == L"d-vhdx")
        return L"d.vhdx";
    else if (format == L"f-vhdx")
        return L"f.vhdx";
    else
        return L"raw.img";
}

auto getTargetForDestination(const std::wstring& destination, const std::wstring& name, const std::wstring& format) {
    npl::spsubject target;
    std::filesystem::path destinationPath(destination);
    if (std::filesystem::is_directory(destinationPath)) {
        target = npl::make_file(destination + L"\\" + name + L"." +
            osl::get_timestamp() + L"." + getExtentionForFormat(format), true);
    } else {
        auto [protocol, username, password, host, port, directory] =
            osl::parseUrl(osl::ws2s(destination));
        if (!host.size() || !protocol.size() || !port.size()) return target;
        auto protect = (protocol == "ftps") ? npl::tls::yes : npl::tls::no;
        auto ftp = npl::make_ftp(host, std::stoi(port), protect);
        if (!ftp) return target;
        ftp->set_credentials(username, password);
        ftp->start_protocol_client();
        auto file = "/" + directory + "/" + osl::ws2s(name + L"." + getExtentionForFormat(format));
        ftp->Transfer(npl::ftp::upload, file,
            [&](const char *b, size_t n) {
                return true;
            }, {}, protect);
        ftp->Quit();
        target = ftp;
    }
    return target;
}

auto recover_virtual_disk(const std::wstring& image, const std::wstring& blkdev) {
    auto disk = fxc::get_virtual_disk(image);
    if (!disk) {
        LOG << "Failed to create virtaul disk object";
        return false;
    }
    auto target = osl::GetBlockDeviceHandle(blkdev);
    if (target == INVALID_HANDLE_VALUE) {
        LOG << "Failed to open block device " << blkdev.c_str() << ", error " << GetLastError();
        return false;
    }
    bool isdisk = blkdev.find(L"\\\\.\\PhysicalDrive") == 0;
    if (!isdisk) {
        auto fRet = osl::LockAndDismountVolume(target);
        if (fRet == FALSE) {
            LOG << "LockAndDismountVolume failed";
            osl::unlockVolume(target);
            return false;
        }
    }
    uint64_t nDone = 0;
    DWORD dwBytesWritten;
    auto bs = disk->getBlockSize();
    auto buf = std::make_unique<uint8_t []>(bs);
    uint64_t nTotal = isdisk ? disk->getLogicalDiskLength() :
        disk->getPartitionLength(0);
    uint64_t offset = isdisk ? 0 : disk->getPartitionStartOffset(0);
    do {
        auto pending = nTotal - nDone;
        size_t nToRead = pending > bs ? bs : pending;
        auto n = disk->read_sync(buf.get(), nToRead, offset + nDone);
        if (n != nToRead) {
            LOG << "read_sync on source returned " << n;
            break;
        }
        auto fRet = WriteFile(target, buf.get(), n, &dwBytesWritten, NULL);
        if (!fRet) {
            LOG << "WriteFile on target failed : " << GetLastError();
            break;
        }
        nDone += n;
        LOG << "n : " << n << " nDone : " << nDone;
    } while (nDone != nTotal);
    LOG << "nTotal : " << nTotal;
    if (!isdisk) {
        osl::unlockVolume(target);
    }
    return (nDone == nTotal);
}

auto recover_volume_to_volume(const std::wstring& sourcevol, const std::wstring& targetvol) {
    BOOL fRet = FALSE;
    DWORD dwBytesWritten = 0;
    DWORD lpNumberOfBytesRead = 0;
    std::unique_ptr<uint8_t[]> _buf;
    auto source = osl::GetVolumeHandle(sourcevol.c_str());
    if (source == INVALID_HANDLE_VALUE) {
        LOG << "Failed to open " << sourcevol << ", error : " << GetLastError();
        return fRet;
    }
    if (!osl::AllowExtendedDasdIO(source)) {
        LOG << "AllowExtendedDasdIO failed, error : " << GetLastError();
        CloseHandle(source);
        return fRet;
    }
    auto target = osl::GetVolumeHandle(targetvol.c_str());
    if (target == INVALID_HANDLE_VALUE) {
        LOG << "Failed to open target " << targetvol.c_str() << ", error " << GetLastError();
        goto _end;
    }
    fRet = osl::LockAndDismountVolume(target);
    if (fRet == FALSE) {
        LOG << "LockAndDismountTargetBlockDevice failed";
        goto _end;
    }
    _buf = std::make_unique<uint8_t []>(_1M);
    do {
        fRet = ReadFile(source, _buf.get(), _1M, &lpNumberOfBytesRead, NULL);
        if (fRet) {
            fRet = WriteFile(target, _buf.get(), lpNumberOfBytesRead, &dwBytesWritten, NULL);
            if (fRet == FALSE) {
                LOG << "WriteFile on target failed, error : " << GetLastError();
            }
        } else {
            LOG << "ReadFile on source failed, error : " << GetLastError();
        }
        if (lpNumberOfBytesRead < _1M) {
            break;
        }
    } while (fRet);

    _end:
    if (source != INVALID_HANDLE_VALUE) {
        CloseHandle(source);
    }
    if (target != INVALID_HANDLE_VALUE) {
        osl::unlockVolume(target);
    }
    return fRet;
}

auto convertBlockDeviceToVirtualImages(const std::vector<TBackupConfig>& bc, TProgressCallback cbk) {
    std::vector<std::wstring> supported;
    std::vector<std::future<void>> futures1, futures2;
    for (const auto& c : bc) {
        auto [volume, level, format, destination, exclude, live] = c;
        if (fxc::IsVolumeSupported(volume.c_str()) && !live) {
            supported.push_back(volume);
            updateVolumeExludePathsForSnapshot(volume, exclude);
        } else {
            auto target = getTargetForDestination(destination, volume.substr(4, 44), format);
            volume.pop_back();
            if (target)
                futures1.push_back(std::async(std::launch::async, [=](){
                    fxc::createBaseVirtualDiskFromSource(format, volume, target,
                        [=](auto snapshot, auto percent){
                            return cbk(volume, percent);
                        });
                }));
        }
    }
    if (supported.size()) {
        CreateSnapshot(
            supported,
            [&] (fxc::TSnapshotSet ss) {
                for (int i = 0; i < ss.size(); i++) {
                    auto [inputVolume, snapshotDevice, originalVolume] = ss[i];
                    LOG << L" " << inputVolume << L" " << snapshotDevice << L" " << originalVolume;
                    std::wstring folder = L"";
                    std::wstring format = L"";
                    for (const auto& c : bc) {
                        if (c.m_volume == inputVolume) {
                            folder = c.m_destination;
                            format = c.m_format;
                        }
                    }
                    auto target = getTargetForDestination(folder, originalVolume.substr(4, 44), format);
                    if (target)
                        futures2.push_back(std::async(std::launch::async,
                            [=](){
                                fxc::createBaseVirtualDiskFromSource(format, snapshotDevice, target,
                                    [=](auto snapshot, auto percent) {
                                        return cbk(inputVolume, percent);
                                    });
                            }));
                }
                for (auto& f : futures2) f.get();
            });
    }
    for (auto& f : futures1) f.get();
    return true;
}

auto mount_virtual_image(const TMountConfig& mc) {
    return false;
}

auto usage(void) {
    LOG << " ";
    LOG << " fxc -d[ump] <file>";
    LOG << " fxc -f[ull] <vhd[x]> <source> <file>";
    LOG << " fxc -i[ncr] <vhd[x]> <source> <parent-path> <target-file> <rctid>";
    LOG << " fxc -r c:\\child.vhd \\\\?\\H:";
}

auto entry(std::vector<std::string> s_arguments) {
    if (s_arguments.size() == 1) {
        usage();
        return 0;
    }
    std::vector<std::wstring> arguments;
    for (const auto& a : s_arguments) {
        arguments.push_back(osl::s2ws(a));
    }
    auto cmd = arguments[1];
    arguments.erase(arguments.begin());
    arguments.erase(arguments.begin());
    if (cmd == L"-s") {
        fxc::testSnapshot(arguments);
    } else if (cmd == L"-d") {
        fxc::dump_virtual_disk(arguments[0]);
    } else if (cmd == L"-f") {
        fxc::createBaseVirtualDiskFromSource(
            arguments[0],
            arguments[1],
            npl::make_file(arguments[2], true),
            nullptr);
    } else if (cmd == L"-i") {
        fxc::createIncrementalVirtualDiskFromSource(
            arguments[0],
            arguments[1],
            arguments[2],
            npl::make_file(arguments[3], true),
            arguments[4]);
    } else if (cmd == L"-rtc") {
        fxc::resilientChangeTrackingToDataBlockIO(
            arguments[0], // source live vhd
            arguments[1], // rctid
            _2M);
    } else if (cmd == L"-r") {
        fxc::recover_virtual_disk(
            arguments[0], // path to a child(image)
            arguments[1]); // volume device: \\?\H:
    } else {
        usage();
    }
    return 0;
}

} //namespace fxc

#endif //FXC_HPP

// 2GB base parent
// create vdisk file="D:\base.vhd" maximum=2000 type=expandable
// create vdisk file="D:\child.vhd" parent="D:\base.vhd"