#ifndef FXC_HPP
#define FXC_HPP

#include <future>
#include <iostream>

#include <npl/npl>

#include <fxc/vd/vd>
#include <fxc/ss/ss>
#include <fxc/rct/rct>

namespace fxc {

struct TBackupConfig
{
  std::wstring m_volume;
  std::wstring m_level;
  std::wstring m_folder;
  std::wstring m_format;
  std::wstring m_exclude;
};

auto usage(void)
{
  std::cout << std::endl;
  std::cout << " fxc -d[ump] <file>" << std::endl;
  std::cout << " fxc -f[ull] <vhd[x]> <source> <file>" << std::endl;
  std::cout << " fxc -i[ncr] <vhd[x]> <source> <parent-path> <target-file> <rctid>" << std::endl;
  std::cout << std::endl;
}

auto RecoverVirtualImageToPhysicalVolume(const std::wstring& source, const std::wstring& target)
{
  auto disk = fxc::make_virtual_disk(source);

  if (!disk)
  {
    std::cout << "Failed to create virtaul disk object\n";
    return false;
  }

  HANDLE hTarget = osl::GetVolumeHandle(target.c_str());

  if (hTarget == INVALID_HANDLE_VALUE)
  {
    std::cout << "Failed to open target " << target.c_str() << ", error " << GetLastError() << std::endl;
    return false;
  }

  std::unique_ptr<uint8_t[]> buf;

  bool fRet = osl::LockAndDismountVolume(hTarget);

  if (fRet == FALSE)
  {
    std::cout << "LockAndDismountVolume failed\n";
    osl::UnlockVolume(hTarget);
    return false;
  }

  uint64_t nDone = 0;
  DWORD dwBytesWritten;
  auto bs = disk->GetBlockSize();
  buf = std::make_unique<uint8_t []>(bs);

  uint64_t nTotal = disk->GetPartitionLength(0);
  uint64_t offset = disk->GetPartitionStartOffset(0);

  do
  {
    auto pending = nTotal - nDone;

    size_t nToRead = pending > bs ? bs : pending;

    auto n = disk->ReadSync(buf.get(), nToRead, offset + nDone);

    fRet = false;

    if (n != nToRead)
    {
      std::cout << "ReadSync on source returned " << n << std::endl;
      break;
    }

    fRet = WriteFile(hTarget, buf.get(), n, &dwBytesWritten, NULL);

    if(!fRet)
    {
      std::cout << "WriteFile on target failed : " << GetLastError();
      break;
    }

    nDone += n;

    std::cout << "n : " << n << " nDone : " << nDone << std::endl;

  } while (nDone != nTotal);

  std::cout << "nTotal : " << nTotal << std::endl;

  return fRet;
}

auto RecoverVolumeToVolume(const std::wstring& source, const std::wstring& target) 
{
  BOOL fRet = FALSE;
  std::unique_ptr<uint8_t[]> _buf;
  HANDLE hSource = INVALID_HANDLE_VALUE;
  HANDLE hTarget = INVALID_HANDLE_VALUE;
  DWORD dwBytesWritten = 0;
  DWORD lpNumberOfBytesRead = 0;
  
  hSource = osl::GetVolumeHandle(source.c_str());

  if (hSource == INVALID_HANDLE_VALUE)
  {
    std::cout << "Failed to open source volume, error : " << GetLastError() << std::endl;
    goto _end;
  }

  fRet = DeviceIoControl(
            hSource,
            FSCTL_ALLOW_EXTENDED_DASD_IO,
            NULL,
            0,
            NULL,
            0,
            NULL,
            NULL);

  if (fRet == FALSE)
  {
    std::cout << "EXTENDED_DASD_IO failed on source, error : " << GetLastError() << std::endl;
    goto _end;
  }

  hTarget = osl::GetVolumeHandle(target.c_str());

  if (hTarget == INVALID_HANDLE_VALUE)
  {
    std::cout << "Failed to open target " << target.c_str() << ", error " << GetLastError() << std::endl;
    goto _end;
  }

  fRet = osl::LockAndDismountVolume(hTarget);

  if (fRet == FALSE)
  {
    std::cout << "LockAndDismountTargetBlockDevice failed\n";
    goto _end;
  }

  _buf = std::make_unique<uint8_t []>(_1M);

  do
  {
    fRet = ReadFile(hSource, _buf.get(), _1M, &lpNumberOfBytesRead, NULL);

    if (fRet)
    {
      fRet = WriteFile(hTarget, _buf.get(), lpNumberOfBytesRead, &dwBytesWritten, NULL);

      if (fRet == FALSE)
      {
        std::cout << "WriteFile on target failed, error : " << GetLastError() << std::endl;
      }
    }
    else
    {
      std::cout << "ReadFile on source failed, error : " << GetLastError() << std::endl;
    }

    if (lpNumberOfBytesRead < _1M) break;

  } while (fRet);

  _end:

  if (hSource != INVALID_HANDLE_VALUE)
  {
    CloseHandle(hSource);
  }

  if (hTarget != INVALID_HANDLE_VALUE)
  {
    osl::UnlockVolume(hTarget);
  }

  return fRet;
}

auto ConvertPhysicalVolumesToVirtualImages(const std::vector<TBackupConfig>& configuration, TProgressCallback cbk)
{
  std::vector<std::wstring> supported;

  std::vector<std::future<void>> futures1, futures2;

  for (const auto& config : configuration)
  {
    auto [volume, level, folder, format, exclude] = config;

    if (fxc::IsVolumeSupported(volume.c_str()))
    {
      supported.push_back(volume);
    }
    else
    {
      auto target = folder + L"\\" + volume.substr(4, 44) + L"." + format;

      futures1.push_back(std::async(std::launch::async, [=](){
        fxc::CreateBaseVirtualDisk(format, volume, target,
          [=](auto snapshot, auto percent){
              return cbk(volume, percent);
          });
      }));
    }
  }

  if (supported.size())
  {
    CreateSnapshot(
      supported,
      [&] (fxc::TSnapshotSet ss)
      {
        for (int i = 0; i < ss.size(); i++)
        {
          auto [inputVolume, snapshotDevice, originalVolume] = ss[i];

          std::wcout << " " << inputVolume << " " << snapshotDevice << " " << originalVolume << std::endl;

          std::wstring folder = L"";
          std::wstring format = L"";

          for (const auto& c : configuration)
          {
            if (c.m_volume == inputVolume)
            {
              folder = c.m_folder;
              format = c.m_format;
            }
          }

          auto target = folder + L"\\" + originalVolume.substr(4, 44) + L"." + format;

          futures2.push_back(std::async(std::launch::async, [=](){
            fxc::CreateBaseVirtualDisk(format, snapshotDevice, target,
              [=](auto snapshot, auto percent){
                  return cbk(inputVolume, percent);
              });
          }));
        }
        for (auto& f : futures2) f.get();
      });
  }

  for (auto& f : futures1) f.get();

  return true;
}

auto MountVirtualDiskAsVolume(const std::wstring& image)
{
  return false;
}

auto TestSnapshot(std::vector<std::wstring> volumes)
{
  fxc::EnumerateSnapshots();
  
  std::vector<std::wstring> supported, unsupported;

  for (const auto& volume : volumes)
  {
    if (fxc::IsVolumeSupported(volume))
    {
      supported.push_back(volume);
    }
    else
    {
      std::wcout << " excluding unsupported volume : " << volume << std::endl;
    }
  }

  fxc::CreateSnapshot(
    supported,
    [] (fxc::TSnapshotSet ss) {
      for (auto& s : ss)
      {
        auto [volume, snapshotDevice, volumeDevice] = s;
        std::wcout << " " << volume << " " << snapshotDevice << " " << volumeDevice << std::endl;
      }
    });
}

auto entry(std::vector<std::wstring> arguments)
{
  if (arguments.size() == 1)
  {
    usage();
    return 0;
  }

  auto cmd = arguments[1];

  arguments.erase(arguments.begin());
  arguments.erase(arguments.begin());

  if (cmd == L"-s")
  {
    fxc::TestSnapshot(arguments);
  }
  else if (cmd == L"-d")
  {
    fxc::DumpVirtualDisk(arguments[0]);
  }
  else if (cmd == L"-f")
  {
    fxc::CreateBaseVirtualDisk(
        arguments[0],
        arguments[1],
        arguments[2],
        nullptr);
  }
  else if (cmd == L"-i")
  {
    fxc::CreateIncrementalVirtualDisk(
        arguments[0],
        arguments[1],
        arguments[2],
        arguments[3],
        arguments[4]);
  }
  else if (cmd == L"-r")
  {
    fxc::ResilientChangeTrackingToDataBlockIO(
        arguments[0], // source live vhd
        arguments[1], // rctid
        _2M);
  }
  else
  {
    usage();
  }

  return 0;
}

} //namespace fxc

#endif //FXC_HPP