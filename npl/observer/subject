#ifndef SUBJECT_HPP
#define SUBJECT_HPP

#include <any>
#include <set>
#include <mutex>
#include <vector>
#include <memory>
#include <string>
#include <assert.h>
#include <iostream>
#include <algorithm>
#include <unordered_map>

#include <osl/log>

namespace npl {

template <typename T1, typename T2>
struct subject : public std::enable_shared_from_this<subject<T1, T2>> {

    using wpsubject = std::weak_ptr<subject<T1, T2>>;
    using spsubject = std::shared_ptr<subject<T1, T2>>;

    subject(){}

    subject(const std::string& name) {
        m_name = name;
    }

    virtual ~subject() {
        std::lock_guard<std::mutex> lg(m_lock);
        remove_all_event_listeners();
        DBG << "~subject : " << get_name();
    }

    virtual std::string get_name(void) {
        return m_name;
    }

    static spsubject get_last_target(spsubject sub) {
        while (sub) {
            auto target = (sub->m_target).lock();
            if (!target) break;
            sub = target;
        }
        return sub;
    }

    virtual void * read_async(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) {
        std::lock_guard<std::mutex> lg(m_lock);
        auto target = m_target.lock();
        if (target) {
            return target->read_async(b, l, o);
        }
        return nullptr;
    }

    virtual bool write_async(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) {
        std::lock_guard<std::mutex> lg(m_lock);
        auto target = m_target.lock();
        if (target) {
            return target->write_async(b, l, o);
        }
        return false;
    }

    virtual int32_t read_sync(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) {
        std::lock_guard<std::mutex> lg(m_lock);
        auto target = m_target.lock();
        if (target) {
            return target->read_sync(b, l, o);
        }
        return -1;
    }

    virtual int32_t write_sync(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) {
        std::lock_guard<std::mutex> lg(m_lock);
        auto target = m_target.lock();
        if (target) {
            return target->write_sync(b, l, o);
        }
        return -1;
    }

    virtual void onRead(const T1 *b, size_t n) {
        std::lock_guard<std::mutex> lg(m_lock);
        NotifyRead((const T2 *)b, n);
    }

    virtual void onWrite(const T1 *b, size_t n) {
        std::lock_guard<std::mutex> lg(m_lock);
        NotifyWrite(b, n);
    }

    virtual void onError(uint64_t error) {
        std::lock_guard<std::mutex> lg(m_lock);
        NotifyError(error);
    }

    virtual void onAccept(void) {
        std::lock_guard<std::mutex> lg(m_lock);
        NotifyAccept();
    }

    virtual void onConnect(void) {
        std::lock_guard<std::mutex> lg(m_lock);
        m_connected = true;
        NotifyConnect();
    }

    virtual void onDisconnect(void) {
        std::lock_guard<std::mutex> lg(m_lock);
        m_connected = false;
        NotifyDisconnect();
        mark_remove_all_listeners();
        mark_remove_self_as_listener();
    }

    virtual void onEvent(std::any e) {
        std::lock_guard<std::mutex> lg(m_lock);
        NotifyEvent(e);
    }

    virtual const spsubject& add_event_listener(const spsubject& observer) {
        std::lock_guard<std::mutex> lg(m_lock);
        m_observers.insert(observer);
        observer->set_target(this->weak_from_this());
        return observer;
    }

    auto remove_event_listener(const spsubject& observer) {
        std::lock_guard<std::mutex> lg(m_lock);
        remove_event_listener_internal(observer);
    }

    auto remove_event_listener_internal(const spsubject& observer) {
        auto it = m_observers.find(observer);
        assert(it != m_observers.end());
        return m_observers.erase(it);
    }

    virtual void remove_all_event_listeners(void) {
        m_observers.clear();
        m_removeAllListeners = false;
    }

    virtual void mark_remove_all_listeners(void) {
        m_removeAllListeners = true;
    }

    virtual void mark_remove_self_as_listener(void) {
        m_removeSelfAsListener = true;
    }

    virtual void mark_connected(bool connected) {
        m_connected = connected;
    }

    virtual void mark_stopped(bool stopped) {
        m_stopped = stopped;
    }

    virtual bool is_stopped(void) {
        return m_stopped;
    }

    virtual bool is_connected(void) {
        return m_connected;
    }

    virtual bool is_marked_remove_self_as_listener(void) {
        return m_removeSelfAsListener;
    }

    virtual void set_property(const std::string& key, const std::string& value) {
        std::lock_guard<std::mutex> lg(m_lock);
        m_properties[key] = value;
    }

    virtual std::string get_property(const std::string& key) {
        std::lock_guard<std::mutex> lg(m_lock);
        std::string value = "";
        try {
            value = m_properties.at(key);
        }
        catch (const std::exception& e) {
            DBG << e.what();
        }
        return value;
    }

    virtual int get_property_int(const std::string& key) {
        auto value = get_property(key);
        return std::stoi(value);
    }

    virtual bool get_property_bool(const std::string& key) {
        auto value = get_property(key);
        return ((value.size() && value == "true") ? true : false);
    }

    protected:

    virtual void set_target(const wpsubject& target) {
        std::lock_guard<std::mutex> lg(m_lock);
        m_target = target;
    }

    virtual void reset_subject(spsubject& subject) {
        subject->mark_remove_all_listeners();
        subject->mark_remove_self_as_listener();
        subject.reset();
    }

    virtual void process_listeners_marked_for_removal(void) {
        if (this->m_removeAllListeners) {
            this->remove_all_event_listeners();
            return;
        }
        for (auto it = m_observers.begin(); it != m_observers.end(); ) {
            if ((*it)->is_marked_remove_self_as_listener()) {
                it = this->remove_event_listener_internal(*it);
            } else {
                it++;
            }
        }
    }

    virtual void NotifyError(uint64_t error) {
        for (auto& observer : m_observers) {
            observer->onError(error);
        }
        process_listeners_marked_for_removal();
    }

    virtual void NotifyConnect() {
        for (auto& observer : m_observers) {
            observer->onConnect();
        }
        process_listeners_marked_for_removal();
    }

    virtual void NotifyRead(const T2 *b, size_t n) {
        for (auto& observer : m_observers) {
            observer->onRead(b, n);
        }
        process_listeners_marked_for_removal();
    }

    virtual void NotifyWrite(const T2 *b, size_t n) {
        for (auto& observer : m_observers) {
            observer->onWrite(b, n);
        }
        process_listeners_marked_for_removal();
    }

    virtual void NotifyDisconnect() {
        for (auto& observer : m_observers) {
            observer->onDisconnect();
        }
        process_listeners_marked_for_removal();
    }

    virtual void NotifyAccept(void) {
        for (auto& observer : m_observers) {
            observer->onAccept();
        }
        process_listeners_marked_for_removal();
    }

    virtual void NotifyEvent(std::any e) {
        for (auto& observer : m_observers) {
            observer->onEvent(e);
        }
        process_listeners_marked_for_removal();
    }

    std::mutex m_lock;
    wpsubject m_target;
    std::string m_name = "xxx";

    bool m_stopped = false;
    bool m_connected = false;
    std::set<spsubject> m_observers;
    bool m_removeAllListeners = false;
    bool m_removeSelfAsListener = false;
    std::unordered_map<std::string, std::string> m_properties;
};

template <typename T1, typename T2>
using spsubject = std::shared_ptr<subject<T1, T2>>;
template<typename T1, typename T2>
using wpsubject = std::weak_ptr<subject<T1, T2>>;

} // namespace npl

#endif //SUBJECT_HPP
