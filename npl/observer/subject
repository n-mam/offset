#ifndef SUBJECT_HPP
#define SUBJECT_HPP

#include <any>
#include <set>
#include <mutex>
#include <vector>
#include <memory>
#include <string>
#include <assert.h>
#include <iostream>
#include <algorithm>
#include <unordered_set>

#include <osl/log>

namespace npl {

struct subject : public std::enable_shared_from_this<subject> {

    using wpsubject = std::weak_ptr<subject>;
    using spsubject = std::shared_ptr<subject>;

    enum state : uint8_t {
        connecting, connected, disconnected
    };

    subject() = default;

    virtual ~subject() {
        std::lock_guard<std::mutex> lg(m_lock);
        remove_all_event_listeners();
        DBG << "~subject : " << name();
    }

    uint8_t get_state() {
        return static_cast<uint8_t>(m_state);
    }

    void set_state(uint8_t s) {
        m_state = static_cast<state>(s);
    }

    auto name(void) {
        return m_name;
    }

    bool is_stopped(void) {
        return m_stopped;
    }

    virtual bool is_connected(void) {
        return m_connected;
    }

    void mark_stopped(bool stopped) {
        m_stopped = stopped;
    }

    void mark_connected(bool connected) {
        m_connected = connected;
    }

    void mark_remove_all_listeners(void) {
        m_removeAllListeners = true;
    }

    void remove_all_event_listeners(void) {
        m_observers.clear();
        m_removeAllListeners = false;
    }

    void mark_remove_self_as_listener(void) {
        m_removeSelfAsListener = true;
    }

    bool is_marked_remove_self_as_listener(void) {
        return m_removeSelfAsListener;
    }

    virtual void notify_connect() {
        std::lock_guard<std::mutex> lg(m_lock);
        m_connected = true;
        set_state(state::connected);
        for (auto& observer : m_observers) {
            observer->notify_connect();
        }
    }

    virtual void notify_disconnect() {
        std::lock_guard<std::mutex> lg(m_lock);
        m_connected = false;
        set_state(state::disconnected);
        for (auto& observer : m_observers) {
            observer->notify_disconnect();
        }
        mark_remove_all_listeners();
        mark_remove_self_as_listener();
    }

    virtual void NotifyEvent(std::any e) {
        std::lock_guard<std::mutex> lg(m_lock);
        for (auto& observer : m_observers) {
            observer->NotifyEvent(e);
        }
    }

    virtual void notify_accept(void *ctx) {
        std::lock_guard<std::mutex> lg(m_lock);
        for (auto& observer : m_observers) {
            observer->notify_accept(ctx);
        }
    }

    virtual void notify_error(uint64_t error) {
        std::lock_guard<std::mutex> lg(m_lock);
        for (auto& observer : m_observers) {
            observer->notify_error(error);
        }
    }

    virtual void notify_read(const uint8_t *b, size_t n) {
        std::lock_guard<std::mutex> lg(m_lock);
        for (auto& observer : m_observers) {
            observer->notify_read(b, n);
        }
    }

    virtual void notify_write(const uint8_t *b, size_t n) {
        std::lock_guard<std::mutex> lg(m_lock);
        for (auto& observer : m_observers) {
            observer->notify_write(b, n);
        }
    }

    virtual const spsubject& add_event_listener(const spsubject& observer) {
        std::lock_guard<std::mutex> lg(m_lock);
        m_observers.insert(observer);
        observer->set_target(this->weak_from_this());
        return observer;
    }

    virtual void * read_async(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) {
        std::lock_guard<std::mutex> lg(m_lock);
        auto target = m_target.lock();
        if (target) {
            return target->read_async(b, l, o);
        }
        return nullptr;
    }

    virtual bool write_async(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) {
        std::lock_guard<std::mutex> lg(m_lock);
        auto target = m_target.lock();
        if (target) {
            return target->write_async(b, l, o);
        }
        return false;
    }

    virtual int32_t read_sync(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) {
        std::lock_guard<std::mutex> lg(m_lock);
        auto target = m_target.lock();
        if (target) {
            return target->read_sync(b, l, o);
        }
        return -1;
    }

    virtual int32_t write_sync(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) {
        std::lock_guard<std::mutex> lg(m_lock);
        auto target = m_target.lock();
        if (target) {
            return target->write_sync(b, l, o);
        }
        return -1;
    }

    void process_listeners_marked_for_removal(void) {
        if (this->m_removeAllListeners) {
            this->remove_all_event_listeners();
            return;
        }
        for (auto it = m_observers.begin(); it != m_observers.end(); ) {
            if ((*it)->is_marked_remove_self_as_listener()) {
                it = this->remove_event_listener_internal(*it);
            } else {
                it++;
            }
        }
    }

    static spsubject get_last_target(spsubject sub) {
        while (sub) {
            auto target = (sub->m_target).lock();
            if (!target) break;
            sub = target;
        }
        return sub;
    }

    virtual void add_device_to_event_port(spsubject subject) {}

    auto remove_event_listener_internal(const spsubject& observer) {
        auto it = m_observers.find(observer);
        assert(it != m_observers.end());
        return m_observers.erase(it);
    }

    auto remove_event_listener(const spsubject& observer) {
        std::lock_guard<std::mutex> lg(m_lock);
        remove_event_listener_internal(observer);
    }

    std::string m_name;

    protected:

    void set_target(const wpsubject& target) {
        std::lock_guard<std::mutex> lg(m_lock);
        m_target = target;
    }

    virtual void reset_subject(spsubject& subject) {
        subject->mark_remove_all_listeners();
        subject->mark_remove_self_as_listener();
        subject.reset();
    }

    std::mutex m_lock;
    wpsubject m_target;

    bool m_stopped = false;
    bool m_connected = false;
    state m_state = state::connecting;
    bool m_removeAllListeners = false;
    bool m_removeSelfAsListener = false;
    std::unordered_set<spsubject> m_observers;
};

using spsubject = std::shared_ptr<subject>;
using wpsubject = std::weak_ptr<subject>;

} // namespace npl

#endif //SUBJECT_HPP
