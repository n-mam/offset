#ifndef DISPATCHER_HPP
#define DISPATCHER_HPP

#include <device/socket>
#include <observer/listener>

#include <thread>
#include <vector>
#include <iostream>

#ifdef _WIN32
#include <BaseTsd.h>
typedef SSIZE_T ssize_t;
#endif

#ifdef linux
#include <unistd.h>
#include <sys/epoll.h>
#include <string.h>
#endif

#if __has_include(<sys/event.h>)
#include <sys/types.h>
#include <sys/event.h>
#include <sys/time.h>
#endif

namespace npl {

struct Event {
    #ifdef linux
    uint32_t e;
    bool is_read() { return e & EPOLLIN; }
    bool is_write() { return e & EPOLLOUT; }
    bool is_error() { return e & EPOLLERR; }
    bool is_hangup() { return e & EPOLLHUP; }
    #endif
    #if __has_include(<sys/event.h>)
    short filter;
    u_short flags;
    bool is_read() { return filter == EVFILT_READ; }
    bool is_write() { return filter == EVFILT_WRITE; }
    bool Is_eof() { return flags & EV_EOF; }
    #endif
};

constexpr inline auto context_type_string(
    decltype(context::type) t) {
    switch (t) {
        case context::accept:
            return "onAccept";
            break;
        case context::connect:
            return "onConnect";
            break;
        case context::read:
            return "onRead";
            break;
        case context::write:
            return "onWrite";
            break;
        default:
            return "invalid";
    }
}

struct dispatcher : public subject<uint8_t, uint8_t> {

    dispatcher(const std::string& name = "D") : subject(name) {
        #if __has_include(<sys/event.h>)
        _port = kqueue();
        DBG << "kqueue _port " << _port << ", " << strerror(errno);
        #elif linux
        _port = epoll_create1(0);
        DBG << "epoll _port " << _port << ", " << strerror(errno);
        #elif _WIN32
        _port = CreateIoCompletionPort(INVALID_HANDLE_VALUE, 0, 0, 0);
        DBG << "iocp _port " << _port << ", " << GetLastError();
        #endif
        if (!_thread.joinable()) {
            _thread = std::thread(&dispatcher::event_loop, this);
        }
    }

    ~dispatcher() {
        if (_client) {
            if (_client->is_connected()) {
                _client->stop_socket(true);
            }
        }
        if (_server) {
            _server->stop_socket();
        }
        #ifdef _WIN32
        PostQueuedCompletionStatus(_port, 0, 0, 0);
        #else
        _stop = true; //todo
        #endif
        _thread.join();
        #ifndef _WIN32
        if (_port >= 0) {
            close(_port), _port = 0;
        }
        #else
        if (_port != INVALID_HANDLE_VALUE) {
            CloseHandle(_port), _port = INVALID_HANDLE_VALUE;
        }
        #endif
    }

    inline auto has_control_initialized() {
        // accept completion on server should generally be queued
        // before connect completion of client. However, we check
        // both. this->is_connected happens in the server's onAccept
        return (_client->is_connected() && this->is_connected());
    }

    inline auto initialize_control(void) {
        // connected client read callback
        TListenerOnRead cbk_server_accepted_client_read = {
            [=, this, m = std::string()](const uint8_t *b, size_t n) mutable {
                m.append((char *)b, n);
                if (m.size() >= sizeof(context)) {
                    context *c = (context *)calloc(1, sizeof(context));
                    memmove(c, m.data(), sizeof(context));
                    process_event_context((subject *)c->k, c);
                    m.clear();
                }
            }};
        // control server accept callback
        TListenerOnAccept cbk_server_accept = {
            [=, this] (void *ctx) {
                auto ac_lsnr = std::make_shared<listener>();
                ac_lsnr->setCallback<TListenerOnRead>(cbk_server_accepted_client_read);
                _server->get_accepted_client(((context *)ctx)->as)->add_event_listener(ac_lsnr);
                mark_connected(true);
            }};
        _server = make_server("0.0.0.0", 0, cbk_server_accept, shared_from_this());
        _server->start_socket_server();
        _client = make_client("127.0.0.1", _server->m_port, shared_from_this());
        _client->start_socket_client();
    }

    virtual void add_device_to_event_port(spsubject subject) override {
        auto device = std::dynamic_pointer_cast<FileDeviceType>(subject);
        assert(device);
        #ifdef linux
        assert(device->get_device_type() == device::socket);
        EpollControl(device, EPOLL_CTL_ADD, EPOLLIN | EPOLLOUT | EPOLLET);
        #endif
        #if __has_include(<sys/event.h>)
        struct kevent kevt[2];
        EV_SET(&kevt[0], device->_fd_async, EVFILT_READ, EV_ADD, 0, 0, device.get());
        EV_SET(&kevt[1], device->_fd_async, EVFILT_WRITE, EV_ADD, 0, 0, device.get());
        auto rc = kevent(_port, kevt, 2, NULL, 0, NULL);
        assert(rc != -1);
        #endif
        #ifdef _WIN32
        auto port = CreateIoCompletionPort(
                device->_fd_async,
                _port,
                (ULONG_PTR)device.get(),
                0);
        assert(port);
        #endif
    }

    virtual const spsubject& add_event_listener(const spsubject& observer) override {
        subject::add_event_listener(observer);
        #ifdef _WIN32
        add_device_to_event_port(observer);
        #endif
        return observer;
    }

    private:

    void event_loop(void) {

        while (!_stop) {
            int rc = 0;
            void *k = nullptr;
            uint64_t error = 0;
            #ifdef _WIN32
            LPOVERLAPPED ol;
            unsigned long n;
            rc = GetQueuedCompletionStatus(_port, &n, (PULONG_PTR)&k, &ol, INFINITE);
            if (!rc) {
                error = GetLastError();
                DBG << "GQCS failed : " << error << " "
                        << ((subject<uint8_t, uint8_t> *)k)->get_name();
            }
            if (n == 0 && k == 0 && ol == 0) break;
            #elif linux
            struct epoll_event ee;
            rc = epoll_wait(_port, &ee, 1, -1);
            if (_stop) break;
            k = ee.data.ptr;
            if (rc < 0) {
                error = errno;
                if (errno == EINTR) continue;
                DBG << "epoll_wait failed : " << strerror(error) << " "
                        << (k ? ((subject<uint8_t, uint8_t> *)k)->get_name() : "");
            }
            Event e {ee.events};
            #elif __has_include(<sys/event.h>)
            struct kevent ke;
            rc = kevent(_port, NULL, 0, &ke,	1, nullptr);
            if (_stop) break;
            if (rc < 0) {
                error = errno;
                DBG << "kevent failed : " << strerror(error) << " "
                        << ((subject<uint8_t, uint8_t> *)k)->get_name();
                break;
            }
            k = ke.udata;
            Event e {ke.filter, ke.flags};
            #endif

            if (k == nullptr) break;

            std::unique_lock<std::mutex> ul(m_lock);
            for (auto o : m_observers) {
                if (k == (void *)o.get()) {
                    #ifdef _WIN32
                    ((context *)ol)->n = n;
                    std::vector<context *> contexts { (context *)ol };
                    #else
                    std::vector<context *> contexts = get_event_context(o, e);
                    #endif
                    ul.unlock();
                    for (auto ctx : contexts) {
                        process_event_context(o.get(), ctx, rc, error);
                    }
                    ul.lock();
                    break;
                }
            }
            process_listeners_marked_for_removal();
        }
        DBG << "dispatcher thread returning, observers: " << m_observers.size();
    }

    void process_event_context(void *key, context *ctx, int rc = 1, uint64_t error = 0) {
        auto k = (subject<uint8_t, uint8_t> *) key;
        DBG << k->get_name() << " process_event_context " << std::hex << (uint64_t) k << " "
                <<  context_type_string(ctx->type) << " n " << std::dec << (ssize_t) ctx->n;
        if (rc <= 0) {
            k->onError(error);
        } else if (ctx->type == context::read) {
            if (ctx->n != 0) {
                k->onRead(ctx->b, ctx->n);
            } else {
                k->onDisconnect();
            }
        } else if (ctx->type == context::write) {
            k->onWrite(ctx->b, ctx->n);
        } else if (ctx->type == context::connect) {
            k->onConnect();
        } else if (ctx->type == context::accept) {
            k->onAccept(ctx);
        } else {
            assert(false);
        }

        if (ctx->bFree) {
            free((void *)ctx->b);
        }

        free(ctx);
    }

    #ifndef _WIN32
    std::vector<context *> get_event_context(spsubject o, Event& e) {
        std::vector<context *> contexts;
        auto dev = std::dynamic_pointer_cast<socket_device> (o);
        auto isConnected = dev->is_connected();
        auto isClientSocket = dev->is_client_socket();
        auto isListentingSocket = dev->is_listening_socket();
        if (e.is_write()) {
            DBG << "event::is_write, socket type " << dev->get_socket_type()
                    << " isConnected : " << isConnected;
            if (isClientSocket && !isConnected) {
                // writability implies that the connection process has finished.
                // does not mean success.. it could have failed as well.
                auto ctx = (context *)calloc(1, sizeof(context));
                ctx->type = context::connect;
                ctx->k = dev.get();
                contexts.push_back(ctx);
            }
            #ifdef linux
            EpollControl(dev, EPOLL_CTL_MOD, EPOLLIN | EPOLLET);
            #endif

            #if __has_include(<sys/event.h>)
            struct kevent kevt[1];
            //EV_SET(&kevt[0], dev->_fd_async, EVFILT_READ, EV_ADD, 0, 0, dev.get());
            EV_SET(&kevt[0], dev->_fd_async, EVFILT_WRITE, EV_DELETE, 0, 0, dev.get());
            auto rc = kevent(_port, kevt, 1, NULL, 0, NULL);
            assert(rc != -1);
            #endif
        } else if (e.is_read()) {
            DBG << "event::is_read, socket type " << dev->get_socket_type()
                    << " isConnected : " << isConnected;
            if (isListentingSocket) {
                auto ctx = (context *) calloc(1, sizeof(context));
                ctx->type = context::accept;
                ctx->k = dev.get();
                contexts.push_back(ctx);
            } else if (isConnected) {
                context *ctx = nullptr;
                do {
                    ctx = (context *) dev->read_async();
                    if (ctx) {
                        contexts.push_back(ctx);
                    }
                } while (ctx && ctx->n > 0);
            }
        }
        #ifdef linux
        else if (e.is_error() || e.is_hangup()) {
            DBG << "event::is_hangup, socket type " << dev->get_socket_type()
                    << " isConnected : " << isConnected << " error " <<  strerror(errno);
            auto ctx = (context *) calloc(1, sizeof(context));
            ctx->type = context::read;
            ctx->k = dev.get();
            ctx->n = 0;
            contexts.push_back(ctx);
            // epoll_ctl_del
        }
        #endif
        #if __has_include(<sys/event.h>)
        else if (e.Is_eof()) {
            DBG << "event::is_eof, socket type " << dev->get_socket_type()
                    << " isConnected : " << isConnected << " error " <<  strerror(errno);
        }
        #endif
        return contexts;
    }

    #ifdef linux
    virtual void EpollControl(spfile device, int op, uint32_t flags) {
        struct epoll_event e;
        e.events = flags;
        e.data.ptr = device.get();
        int rc = epoll_ctl(_port, op, device->_fd_async, &e);
        DBG << "epoll_ctl rc " << rc << " error : " << strerror(errno);
        assert(rc == 0);
    }
    #endif

    #endif

    virtual void queue_pending_context(spsubject s, void *c) {
        ((context *)c)->k = s.get();
        _client->write_async((const uint8_t *)c, sizeof(context));
        //todo
    }

    private:

    fd _port;
    spsocket _server;
    spsocket _client;
    bool _stop = false;
    std::thread _thread;
};

} // namespace npl

#endif //DISPATCHER_HPP;