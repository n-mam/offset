#ifndef LISTENER_HPP
#define LISTENER_HPP

#include <functional>

#include <observer/subject>

struct TListenerOnLogin { std::function<void (bool)> cbk; };
struct TListenerOnResponse { std::function<void (const std::string&)> cbk; };
struct TListenerOnAcceptedClientMessage { std::function<void (npl::spsubject, const std::string&)> cbk; };

struct TListenerNotifyConnect { std::function<void (bool)> cbk; };
struct TListenerNotifyAccept { std::function<void (void *)> cbk; };
struct TListenerNotifyError { std::function<void (uint64_t)> cbk; };
struct TListenerNotifyRead { std::function<void (const uint8_t *b, size_t n)> cbk; };
struct TListenerNotifyWrite { std::function<void (const uint8_t *b, size_t n)> cbk; };

namespace npl {

struct listener : public subject {

    listener() = default;
    virtual ~listener(){}

    virtual void notify_connect(void) override {
        subject::notify_connect();
        if (cbkConnect.cbk) {
            cbkConnect.cbk(true);
        }
    }

    virtual void notify_accept(void *ctx) override {
        if (cbkAccept.cbk) {
            cbkAccept.cbk(ctx);
        }
    }

    virtual void notify_disconnect(void) override {
        subject::notify_disconnect();
        if (cbkConnect.cbk) {
            cbkConnect.cbk(false);
        }
    }

    virtual void notify_error(uint64_t error) override {
        if (cbkError.cbk) {
            cbkError.cbk(error);
        }
    }

    virtual void notify_read(const uint8_t *b, size_t n) override {
        if (cbkRead.cbk) {
            cbkRead.cbk(b, n);
        }
    }

    virtual void notify_write(const uint8_t *b, size_t n) override {
        if (cbkWrite.cbk) {
            cbkWrite.cbk(b, n);
        }
    }

    virtual void onLogin(bool success) {
        if (cbkLogin.cbk) {
            cbkLogin.cbk(success);
        }
    }

    virtual void onResponse(const std::string& m) {
        if (cbkResponse.cbk) {
            cbkResponse.cbk(m);
        }
    }

    virtual void OnAcceptedClientMessage(spsubject s, const std::string& m) {
        if (cbkAcceptedClientmessage.cbk) {
            cbkAcceptedClientmessage.cbk(s, m);
        }
    }

    template<typename T>
    void setCallback(T callback) {
        if constexpr(std::is_same<T, TListenerNotifyConnect>::value) {
            cbkConnect = callback;
        } else if constexpr(std::is_same<T, TListenerNotifyRead>::value) {
            cbkRead = callback;
        } else if constexpr(std::is_same<T, TListenerNotifyWrite>::value) {
            cbkWrite = callback;
        } else if constexpr(std::is_same<T, TListenerNotifyAccept>::value) {
            cbkAccept = callback;
        } else if constexpr(std::is_same<T, TListenerNotifyError>::value) {
            cbkError = callback;
        } else if constexpr(std::is_same<T, TListenerOnLogin>::value) {
            cbkLogin = callback;
        } else if constexpr(std::is_same<T, TListenerOnResponse>::value) {
            cbkResponse = callback;
        } else if constexpr(std::is_same<T, TListenerOnAcceptedClientMessage>::value) {
            cbkAcceptedClientmessage = callback;
        }
    }

    protected:

    TListenerOnLogin cbkLogin {nullptr};
    TListenerOnResponse cbkResponse {nullptr};
    TListenerOnAcceptedClientMessage cbkAcceptedClientmessage {nullptr};

    TListenerNotifyRead cbkRead {nullptr};
    TListenerNotifyWrite cbkWrite {nullptr};
    TListenerNotifyError cbkError {nullptr};
    TListenerNotifyAccept cbkAccept {nullptr};
    TListenerNotifyConnect cbkConnect {nullptr};
};

}

#endif