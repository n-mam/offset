#ifndef LISTENER_HPP
#define LISTENER_HPP

#include <functional>

#include <observer/subject>

struct TListenerOnLogin { std::function<void (bool)> cbk; };
struct TListenerOnResponse { std::function<void (const std::string&)> cbk; };
struct TListenerOnAcceptedClientMessage { std::function<void (npl::spsubject, const std::string&)> cbk; };

struct TListenerOnConnect { std::function<void (bool)> cbk; };
struct TListenerOnAccept { std::function<void (void *)> cbk; };
struct TListenerOnError { std::function<void (uint64_t)> cbk; };
struct TListenerOnRead { std::function<void (const uint8_t *b, size_t n)> cbk; };
struct TListenerOnWrite { std::function<void (const uint8_t *b, size_t n)> cbk; };

namespace npl {

struct listener : public subject<uint8_t, uint8_t> {

    listener() = default;
    virtual ~listener(){}

    virtual void onConnect(void) override {
        subject::onConnect();
        if (cbkConnect.cbk) {
            cbkConnect.cbk(true);
        }
    }

    virtual void onAccept(void *ctx) override {
        if (cbkAccept.cbk) {
            cbkAccept.cbk(ctx);
        }
    }

    virtual void onDisconnect(void) override {
        subject::onDisconnect();
        if (cbkConnect.cbk) {
            cbkConnect.cbk(false);
        }
    }

    virtual void onError(uint64_t error) override {
        if (cbkError.cbk) {
            cbkError.cbk(error);
        }
    }

    virtual void onRead(const uint8_t *b, size_t n) override {
        if (cbkRead.cbk) {
            cbkRead.cbk(b, n);
        }
    }

    virtual void onWrite(const uint8_t *b, size_t n) override {
        if (cbkWrite.cbk) {
            cbkWrite.cbk(b, n);
        }
    }

    virtual void onLogin(bool success) {
        if (cbkLogin.cbk) {
            cbkLogin.cbk(success);
        }
    }

    virtual void onResponse(const std::string& m) {
        if (cbkResponse.cbk) {
            cbkResponse.cbk(m);
        }
    }

    virtual void OnAcceptedClientMessage(spsubject s, const std::string& m) {
        if (cbkAcceptedClientmessage.cbk) {
            cbkAcceptedClientmessage.cbk(s, m);
        }
    }

    template<typename T>
    void setCallback(T callback) {
        if constexpr(std::is_same<T, TListenerOnConnect>::value) {
            cbkConnect = callback;
        } else if constexpr(std::is_same<T, TListenerOnRead>::value) {
            cbkRead = callback;
        } else if constexpr(std::is_same<T, TListenerOnWrite>::value) {
            cbkWrite = callback;
        } else if constexpr(std::is_same<T, TListenerOnAccept>::value) {
            cbkAccept = callback;
        } else if constexpr(std::is_same<T, TListenerOnError>::value) {
            cbkError = callback;
        } else if constexpr(std::is_same<T, TListenerOnLogin>::value) {
            cbkLogin = callback;
        } else if constexpr(std::is_same<T, TListenerOnResponse>::value) {
            cbkResponse = callback;
        } else if constexpr(std::is_same<T, TListenerOnAcceptedClientMessage>::value) {
            cbkAcceptedClientmessage = callback;
        }
    }

    protected:

    TListenerOnLogin cbkLogin {nullptr};
    TListenerOnResponse cbkResponse {nullptr};
    TListenerOnAcceptedClientMessage cbkAcceptedClientmessage {nullptr};

    TListenerOnRead cbkRead {nullptr};
    TListenerOnWrite cbkWrite {nullptr};
    TListenerOnError cbkError {nullptr};
    TListenerOnAccept cbkAccept {nullptr};
    TListenerOnConnect cbkConnect {nullptr};
};

}

#endif