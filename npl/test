
void test_http_client(const std::string& host, int port)
{
  for (int i = 0; i < 1; i++)
  {
    auto http = npl::make_http_client(host, port);

    http->StartClient(
      [](auto p)
      {
        std::cout << "client connected" << std::endl;
      }
    );
  }
}

void test_ws_server(const std::string& host, int port)
{
  auto ws = npl::make_ws_server(
    host, port, npl::TLS::Yes, 
    [] (npl::SPProtocol c, const std::string& m) 
    {
      std::cout<< "client : " << m;

      c->SendProtocolMessage(
        (uint8_t *)"server echo : hello", 
        strlen("server echo : hello")
      );
    }
  );

  ws->StartServer();

  getchar();
}

void test_ftp_client(const std::string& host, int port)
{
  /**
   * Create an FTP object.
   */
  auto ftp = npl::make_ftp(host, port, npl::TLS::Yes);

  /**
   * Set the login credentials.
   */
  ftp->SetCredentials("anonymous", "welcome123");

  /**
   * Start the protocol client. This would asynchronously
   * trigger connect and the login sequence
   */
  ftp->StartClient();

  /**
   * Directory listing. The lambda argument is an output callback 
   * which is invoked multiple times with chunks of directory list
   * data. A null "b" (buffer) pointer indicates that there's no 
   * more data. Returning false at any point terminates the transfer.
   */
  ftp->ListDirectory(
    [list = std::string()] (const char *b, size_t n) mutable {
      if (b)
      {
        list.append(std::string(b, n));
      }
      else
      {
        std::cout<< list;
      }
      return true;
    },
    "",
    npl::TLS::Yes
  );

  /**
   * Set the current directory
   */
  ftp->SetCurrentDir("a b c");

  // /**
  //  * File download. Similar to the "List" API. 
  //  * The lambda argument is an output callback which is invoked multiple 
  //  * times with chunks of file data. A null "b" (buffer) pointer indicates 
  //  * that there's no more file data to download. Returning false at any point
  //  * terminates the transfer. local file arg is optional; if not specified then 
  //  * downloaded data can only be accesed via the callback.
  //  */
  // ftp->Download(
  //   [](const char *b, size_t n) {
  //     if (b)
  //       std::cout<< std::string(b, n);
  //     else
  //       std::cout<< "Download complete";
  //     return true;
  //   },
  //   "bootstrap-vcpkg.bat",
  //   "./download.bat",
  //   npl::TLS::Yes
  // );

  // /**
  //  * File upload. The lambda argument is an output callback which is invoked
  //  * multiple times with chunks of file data as they are uploaded. A null "b"
  //  * (buffer) pointer indicates that there's no more file data to be uploaded.
  //  * Returning false from this callback closes the transfer. Data channel 
  //  * protection is clear for the upload implying a granular PROT levels on a 
  //  * per transfer basis.
  //  */
  // ftp->Upload(
  //   [](const char *b, size_t n) {
  //     return true;
  //   },
  //   "README.txt",
  //   "../README.md", 
  //   npl::TLS::No
  // );

  // /**
  //  * Get the current directory
  //  */
  // ftp->GetCurrentDir([](const std::string& resp) {
  //   /**
  //    * "resp" holds the response of PWD command
  //    */
  // });

  // ftp->SetCurrentDir("/");

  /**
   * Quit the session. Sends FTP QUIT command
   * and triggeres the cleanup of "ftp" object
   */
  ftp->Quit();

  getchar();  
}

void test_file_copy(const std::string& source, const std::string& dest)
{
  auto rd = npl::make_file(source);

  auto wd = npl::make_file(dest, true);

  constexpr int bufSize = (1 * 1024 * 1024);

  uint8_t *buf = (uint8_t *) calloc(bufSize, 1);

  auto obv = std::make_shared<npl::Listener>(
    nullptr,
    [wd, off = 0ULL](const uint8_t *b, size_t n) mutable
    {
      std::cout<< "onread " << n << ", off " << off;

      if (n)
      {
        wd->Write(b, n, off);
      }

      off += n;
    },
    [rd, off = 0ULL, bufSize](const uint8_t *b, size_t n) mutable
    {
      std::cout<< "onwrite " << n << ", off " << off;

      if (n)
      {
        rd->Read(b, bufSize, off += n);
      }
    }
  );

  rd->AddEventListener(obv);
  wd->AddEventListener(obv);

  rd->Read(buf, bufSize, 0);

  getchar();
}