#ifndef FTP_HPP
#define FTP_HPP

#include <list>
#include <mutex>
#include <regex>
#include <atomic>
#include <vector>
#include <string>
#include <sstream>
#include <cstring>
#include <functional>
#include <condition_variable>

#include <observer/listener>
#include <protocol/protocol>

namespace npl {

struct ftp_message : public message {
    ftp_message(const std::vector<uint8_t>& m) : message(m) {}
};

struct ftp : public protocol {

    using TStateFn = std::function<void (void)>;
    using TTransferCbk = std::function<bool (const char *, size_t)>;

    enum state : uint8_t {
        EStateInit = protocol::state::connected,
        EStateFTPS,
        EStateTLS,
        EStateADAT,
        EStateAUTH,
        EStateUSER,
        EStatePASS,
        EStateACCT,
        EStatePASV,
        EStateDATA,
        EStateREADY,
        EState1YZ,
        EStateXYZ,
        EStateGEN
    };

    enum Direction : uint8_t {
        none,
        list,
        upload,
        download
    };

    virtual ~ftp() {}

    virtual int32_t write_sync(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) override {
        std::unique_lock<std::mutex> ul(m_mux);
        m_cv.wait(ul, [&](){ return m_uploadChannelReady; });
        bool fRet = false;
        if (m_data_channel) {
            m_uploadChannelReady = false;
            if (b && l) {
                fRet = m_data_channel->write_async(b, l);
            } else {
                m_data_channel->stop_socket();
            }
        }
        return fRet ? (int32_t)l : 0;
    }

    virtual bool write_async(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) override {
        return m_data_channel->write_async(b, l);
    }

    virtual void Transfer(Direction direction, const std::string& remote, TTransferCbk tcbk, TListenerOnResponse rcbk = {}, tls P = tls::no) {
        std::lock_guard<std::mutex> lg(m_qlock);
        if (remote.empty() || !tcbk) assert(false);
        bool bQWasEmpty = m_queue.empty();
        SetDCProtLevel(P);
        std::string command;
        if (direction == ftp::list) {
            HasFeature("MLSD") ?
                command = "MLSD" : command = "LIST";
        } else if (direction == ftp::upload) {
            command = "STOR";
        } else if (direction == ftp::download) {
            command = "RETR";
        }
        m_queue.push_back({"TYPE", "I"});
        m_queue.push_back({"PASV"});
        m_queue.push_back({command.c_str(), remote, rcbk, tcbk});
        m_pending_transfers++;
        CheckQueue(bQWasEmpty);
    }

    virtual void GetCurrentDirectory(TListenerOnResponse cbk = {}) {
        std::lock_guard<std::mutex> lg(m_qlock);
        bool bQWasEmpty = m_queue.empty();
        m_queue.push_back({"PWD", "", cbk, nullptr});
        CheckQueue(bQWasEmpty);
    }

    virtual void SetCurrentDirectory(const std::string& dir, TListenerOnResponse cbk = {}) {
        std::lock_guard<std::mutex> lg(m_qlock);
        bool bQWasEmpty = m_queue.empty();
        m_queue.push_back({"CWD", dir, cbk, nullptr});
        CheckQueue(bQWasEmpty);
    }

    virtual void CreateDirectory(const std::string& dir, TListenerOnResponse cbk = {}) {
        std::lock_guard<std::mutex> lg(m_qlock);
        bool bQWasEmpty = m_queue.empty();
        m_queue.push_back({"MKD", dir, cbk, nullptr});
        CheckQueue(bQWasEmpty);
    }

    virtual void RemoveDirectory(const std::string& dir, TListenerOnResponse cbk = {}) {
        std::lock_guard<std::mutex> lg(m_qlock);
        bool bQWasEmpty = m_queue.empty();
        m_queue.push_back({"RMD", dir, cbk, nullptr});
        CheckQueue(bQWasEmpty);
    }

    virtual void RemoveFile(const std::string& file, TListenerOnResponse cbk = {}) {
        std::lock_guard<std::mutex> lg(m_qlock);
        bool bQWasEmpty = m_queue.empty();
        m_queue.push_back({"DELE", file, cbk, nullptr});
        CheckQueue(bQWasEmpty);
    }

    virtual void Rename(const std::string& from, const std::string& to, TListenerOnResponse cbk = {}) {
        std::lock_guard<std::mutex> lg(m_qlock);
        bool bQWasEmpty = m_queue.empty();
        m_queue.push_back({"RNFR", from, cbk, nullptr});
        m_queue.push_back({"RNTO", to, cbk, nullptr});
        CheckQueue(bQWasEmpty);
    }

    virtual void Quit(TListenerOnResponse cbk = {}) {
        std::lock_guard<std::mutex> lg(m_qlock);
        bool bQWasEmpty = m_queue.empty();
        m_queue.push_back({"QUIT", "", cbk, nullptr});
        CheckQueue(bQWasEmpty);
    }

    virtual bool HasFeature(const std::string& feature) {
        return m_feat.find(feature) != std::string::npos;
    }

    virtual std::string SystemType(void) {
        return m_syst;
    }

    virtual int PendingTransfers(void) {
        return m_pending_transfers;
    }

    virtual void set_idle_callback(std::function<void ()> callback) {
        m_idle_callback = callback;
    }

    protected:

    struct Command {
        std::string c_name;
        std::string c_args;
        TListenerOnResponse c_rcbk = {};
        TTransferCbk c_tcbk = nullptr;
    };

    struct Transition {
        ftp::state  t_state;
        char        t_response_code;
        ftp::state  t_next_state;
        TStateFn    t_transition_fn;
        uint8_t     t_flags = 0x00;
    };

    int m_dc_port;
    std::mutex m_mux;
    std::string m_feat;
    std::string m_syst;
    std::mutex m_qlock;
    std::string m_dc_host;
    tls m_dc_tls = tls::no;
    uint8_t m_triggerFlags;
    std::list<Command> m_queue;
    int m_pending_transfers = 0;
    Direction m_currentDirection;
    std::condition_variable m_cv;
    bool m_uploadChannelReady = false;
    spsocket m_data_channel = nullptr;
    std::function<void ()> m_idle_callback;

    #define NEXT 0x10

    Transition FSM[31] = {
        // Connection states
        { state::EStateInit , '1', state::EStateInit  , nullptr                                            },
        { state::EStateInit , '2', state::EStateFTPS  , [this] () { CheckExplicitFTPS();                   }, NEXT    },
        { state::EStateInit , '4', state::EStateInit  , nullptr                                            },
        // AUTH TLS states
        { state::EStateAUTH , '2', state::EStateTLS   , [this] () { DoCCHandshake();                       },     1   },
        { state::EStateAUTH , '3', state::EStateADAT  , nullptr                                             ,     1   },
        { state::EStateAUTH , '4', state::EStateUSER  , [this] () { m_queue.push_front({"USER", m_user});  }, NEXT|1  },
        { state::EStateAUTH , '5', state::EStateUSER  , [this] () { m_queue.push_front({"USER", m_user});  }, NEXT|1  },
        // USER states
        { state::EStateUSER , '1', state::EStateUSER  , nullptr                                            },
        { state::EStateUSER , '2', state::EStateUSER  , [this] () { ProcessLoginEvent(true);               },    NEXT|1  },
        { state::EStateUSER , '3', state::EStatePASS  , [this] () { m_queue.push_front({"PASS", m_password}); }, NEXT|1  },
        { state::EStateUSER , '4', state::EStateUSER  , nullptr                                            },
        { state::EStateUSER , '5', state::EStateUSER  , nullptr                                            },
        // PASS states
        { state::EStatePASS , '1', state::EStateUSER  , [this] () { ProcessLoginEvent(false);              },         },
        { state::EStatePASS , '2', state::EStateREADY , [this] () { ProcessLoginEvent(true);               }, NEXT|1  },
        { state::EStatePASS , '3', state::EStateACCT  , [this] () { m_queue.push_back({"ACCT"});           },         },
        { state::EStatePASS , '4', state::EStateUSER  , [this] () { ProcessLoginEvent(false);              },         },
        { state::EStatePASS , '5', state::EStateUSER  , [this] () { ProcessLoginEvent(false);              },         },
        // PASV states
        { state::EStatePASV , '1', state::EStateREADY , nullptr                                             , NEXT|2   },
        { state::EStatePASV , '2', state::EStateDATA  , [this] () { ProcessPasvResponse();                 }, NEXT|1   },
        { state::EStatePASV , '4', state::EStateREADY , nullptr                                             , NEXT|2   },
        { state::EStatePASV , '5', state::EStateREADY , nullptr                                             , NEXT|2   },
        // DATA command (LIST, RETR, STOR) states
        { state::EStateDATA , '1', state::EState1YZ   , [this] () { ProcessDataCmdResponse('1');           }           },
        { state::EState1YZ  , '2', state::EStateXYZ   , [this] () { ProcessDataCmdResponse('2');           }           },
        { state::EState1YZ  , '4', state::EStateXYZ   , [this] () { ProcessDataCmdResponse('4');           }           },
        { state::EStateDATA , '4', state::EStateXYZ   , [this] () { ProcessDataCmdResponse('4');           }           },
        { state::EStateDATA , '5', state::EStateXYZ   , [this] () { ProcessDataCmdResponse('5');           }           },
        { state::EStateGEN  , '1', state::EStateREADY , nullptr                                             , NEXT|1   },
        { state::EStateGEN  , '2', state::EStateREADY , nullptr                                             , NEXT|1   },
        { state::EStateGEN  , '3', state::EStateREADY , nullptr                                             , NEXT|1   },
        { state::EStateGEN  , '4', state::EStateREADY , nullptr                                             , NEXT|1   },
        { state::EStateGEN  , '5', state::EStateREADY , nullptr                                             , NEXT|1   }
    };

    virtual void state_machine(spmessage msg) override {
        std::lock_guard<std::mutex> lg(m_qlock);
        auto l = msg->get_payload_length();
        auto b = msg->get_payload_buffer();
        LOG << "Response : " << std::string(b, l);
        for (int i = 0; i < sizeof(FSM) / sizeof(FSM[0]); i++) {
            Transition t = FSM[i];
            if ((t.t_state == get_state()) && (t.t_response_code ==  b[0])) {
                // DBG << +t.iState << " -> " << +t.iNextState
                //   << ", " << +t.iFlags << ", " << m_queue.size();
                set_state(t.t_next_state);
                if (!m_queue.empty()) {
                    onResponse(msg->get_payload_string());
                    uint8_t f_skip = t.t_flags & 0x0F;
                    for (auto i = 0; i < f_skip; i++) {
                        m_queue.pop_front();
                    }
                }
                if (t.t_transition_fn) {
                    t.t_transition_fn();
                }
                auto next = (t.t_flags >> 4) & 0x0F;
                if (next) {
                    TriggerNextCommand();
                }
                break;
            }
        }
        if (m_queue.empty()) {
            if (m_idle_callback)
                m_idle_callback();
        }
    }

    virtual spmessage is_message_complete(const std::vector<uint8_t>& b) override {
        size_t l = b.size();
        if (l >= 4) {
            if ((b[l-2] == '\r') && (b[l-1] == '\n')) {
                uint8_t code[4] = { 0, 0, 0, ' '};
                memmove(code, b.data(), 3);
                for (size_t i = 0; i < l; i++) {
                    if (0 == memcmp(b.data() + i, code, 4)) {
                        return std::make_shared<ftp_message>(b);
                    }
                }
            }
        }
        return nullptr;
    }

    virtual void SendCommand(const std::string& c, const std::string& arg = "") {
        SetCurrentDirection(c);
        auto cmd = c + " " + arg + "\r\n";
        LOG << "Command  : " << cmd;
        auto target = m_target.lock();
        if (target) {
            target->write_async((uint8_t *)cmd.c_str(), cmd.size(), 0);
            if (IsTransferCommand(cmd)) {
                OpenDataChannel();
            }
        }
    }

    virtual void SetDCProtLevel(tls P) {
        auto tls = get_channel_tls();
        if (tls == tls::yes || tls == tls::implicit) {
            m_queue.push_back({"PBSZ", "0"});
            auto level = (P == tls::no) ? "C" : "P";
            m_queue.push_back({"PROT", level,
                {[this, P](const std::string& res){
                    if (res[0] == '2') {
                        m_dc_tls = P;
                    }
                }}, nullptr});
        }
    }

    virtual void TriggerNextCommand(void) {
        if (!m_queue.empty()) {
            auto& cmd = m_queue.front();
            UpdateProtocolState(cmd.c_name);
            setCallback<TListenerOnResponse>(cmd.c_rcbk);
            SendCommand(cmd.c_name, cmd.c_args);
        }
    }

    virtual void UpdateProtocolState(const std::string& cmd) {
        if (cmd == "AUTH") {
            set_state(state::EStateAUTH);
        } else if (cmd == "USER") {
            set_state(state::EStateUSER);
        } else if (cmd == "PASS") {
            set_state(state::EStatePASS);
        } else if (cmd == "PASV") {
            set_state(state::EStatePASV);
        } else if (IsTransferCommand(cmd)) {
            set_state(state::EStateDATA);
        } else {
            set_state(state::EStateGEN);
        }
    }

    virtual void CheckExplicitFTPS(void) {
        auto tls = get_channel_tls();
        if (tls == tls::yes) {
            m_queue.push_front({"AUTH", "TLS",
                {[this](const auto& res) {
                    if (!IsPositiveCompletionReply(res[0]))
                        set_channel_tls(tls::no);
                }}});
        } else {
            m_queue.push_front({"USER", m_user});
        }
    }

    void SetCurrentDirection(const std::string& cmd) {
        if (cmd == "LIST" || cmd == "MLSD") {
            m_currentDirection = ftp::download;
        } else if (cmd == "RETR") {
            m_currentDirection = ftp::download;
        } else if (cmd == "STOR") {
            m_currentDirection = ftp::upload;
        } else {
            m_currentDirection = ftp::none;
        }
    }

    virtual void ProcessDataCmdResponse(char code) {
        if (IsPositivePreliminaryReply(code)) {
            TriggerDataTransfer(3);
        } else if (IsPositiveCompletionReply(code)) {
            if (!m_data_channel) {
                m_queue.pop_front();
                set_state(state::EStateREADY);
                TriggerNextCommand();
            }
        } else {
            if (m_data_channel) {
                m_data_channel->stop_socket();
                m_data_channel.reset();
            }
            if (m_currentDirection == ftp::upload){
                NotifyUploadChannelReady();
            }
        }
    }

    virtual void ProcessPasvResponse(void) {
        auto& m = _messages.back();
        auto& pasv = m->get_payload_string();
        auto spec = pasv.substr(pasv.find('('));
        uint32_t h1, h2, h3, h4, p1, p2;
        int fRet = sscanf(spec.c_str(), "(%d,%d,%d,%d,%d,%d)", &h1, &h2, &h3, &h4, &p1, &p2);
        if (fRet == 6) {
            m_dc_host = std::to_string(h1) + "." +
                        std::to_string(h2) + "." +
                        std::to_string(h3) + "." +
                        std::to_string(h4);
            m_dc_port = (p1 << 8) + p2;
        } else {
            LOG << "Failed to parse PASV response; checking EPASV..";
            std::regex regex(R"(\(\|\|\|(\d+)\|)");
            std::smatch match;
            if (std::regex_search(pasv, match, regex)) {
                m_dc_port = std::stoi(match[1].str());
                std::cout << "EPASV port: " << m_dc_port << std::endl;
            } else {
                std::cout << "No port found in the response!" << std::endl;
            }
            auto cc = std::static_pointer_cast<socket_device>(m_target.lock());
            m_dc_host = cc->m_host;
        }
    }

    virtual void OpenDataChannel() {
        m_data_channel = std::make_shared<socket_device>();
        get_last_target(shared_from_this())->add_event_listener(m_data_channel);
        m_data_channel->set_host_and_port(m_dc_host, m_dc_port);
        AttachDataChannelObserver();
        m_triggerFlags = 0;
        m_data_channel->start_socket_client();
    }

    virtual void AttachDataChannelObserver(void) {
        auto observer = std::make_shared<listener>();
        observer->setCallback<TListenerNotifyConnect>({
            [this](bool connected) {
                connected ? OnDataChannelConnect() :
                    OnDataChannelDisconnect();
            }});
        observer->setCallback<TListenerNotifyRead>({
            [this](const uint8_t *b, size_t n) {
                if (!m_data_channel->is_stopped())
                    OnDataChannelIoCompletion(b, n, ftp::download);
            }});
        observer->setCallback<TListenerNotifyWrite>({
            [this](const uint8_t *b, size_t n) {
                if (!m_data_channel->is_stopped())
                    OnDataChannelIoCompletion(b, n, ftp::upload);
            }});
        observer->setCallback<TListenerNotifyError>({
            [this](uint64_t e){
                OnDataChannelDisconnect();
            }});
        m_data_channel->add_event_listener(observer);
    }

    virtual void OnDataChannelConnect(void) {
        TriggerDataTransfer(2);
    }

    virtual void OnDataChannelIoCompletion(const uint8_t *b, size_t n, Direction direction) {
        if (direction == m_currentDirection) {
            auto& transferCallback = m_queue.front().c_tcbk;
            if (transferCallback) {
                auto continueTransfer = transferCallback((const char *)b, n);
                if (!continueTransfer) {
                    m_data_channel->stop_socket
                        (direction == ftp::download ? true : false);
                }
                if (direction == ftp::upload) {
                    NotifyUploadChannelReady();
                }
            }
        }
    }

    virtual void OnDataChannelDisconnect(void) {
        m_pending_transfers--;
        auto& transferCallback = m_queue.front().c_tcbk;
        if (transferCallback) {
            transferCallback(nullptr, 0);
        }
        ProcessDataCmdResponse('0');
        if (get_state() == state::EStateXYZ) {
            m_queue.pop_front();
            set_state(state::EStateREADY);
            TriggerNextCommand();
        }
    }

    virtual void TriggerDataTransfer(int source) {
        osl::set_bit(m_triggerFlags, source);
        if (!osl::is_bit_set(m_triggerFlags, 1) &&
            osl::is_bit_set(m_triggerFlags, 2) &&
            osl::is_bit_set(m_triggerFlags, 3)) {
            if (m_dc_tls == tls::yes) {
                auto cc = std::static_pointer_cast<socket_device>(m_target.lock());
                m_data_channel->initialize_ssl(cc->get_ssl_object(),
                    [this](){
                        if (m_currentDirection == ftp::upload)
                            m_queue.front().c_tcbk((char *)0xABCDEF, 0);
                    });
            } else {
                if (m_currentDirection == ftp::upload) {
                    m_queue.front().c_tcbk((char *)0xABCDEF, 0);
                }
            }
            osl::set_bit(m_triggerFlags, 1);
        }
    }

    virtual void NotifyUploadChannelReady() {
        std::lock_guard<std::mutex> lg(m_mux);
        m_uploadChannelReady = true;
        m_cv.notify_all();
    }

    virtual void ProcessLoginEvent(bool success) {
        if (!success) {
            m_queue.clear();
            LOG << "User login failed";
            NotifyUploadChannelReady();
            onLogin(false);
        } else {
            m_queue.push_front({
                "SYST", "",
                {[this](auto res) {
                    m_syst = res;
                }}
            });
            m_queue.push_front({
                "FEAT", "",
                {[this](auto res) {
                    m_feat = res;
                    onLogin(true);
                }}
            });
        }
    }

    virtual bool IsTransferCommand(const std::string& command) {
        std::string_view view(command.c_str(), 4);
        return (view == "RETR" ||
                view == "STOR" ||
                view == "MLSD" ||
                view == "LIST");
    }

    virtual bool IsPositiveCompletionReply(char c) {
        return (c == '2');
    }

    virtual bool IsPositivePreliminaryReply(char c) {
        return (c == '1');
    }

    virtual void notify_error(uint64_t error) override {
        STATUS(1) << "control channel error " << error;
    }

    virtual void notify_disconnect(void) override {
        protocol::notify_disconnect();
    }

    virtual void notify_connect(void) override {
        protocol::notify_connect();
        auto tls = get_channel_tls();
        if (tls == tls::implicit){
            DoCCHandshake();
        }
    }

    virtual void DoCCHandshake() {
        auto sock = get_target_socket_device();
        if (sock) {
            sock->initialize_ssl(
                nullptr,
                [this]() {
                    auto tls = get_channel_tls();
                    if (tls == tls::yes) {
                        m_queue.push_front({"USER", m_user});
                    }
                    TriggerNextCommand();
                }
            );
        }
    }

    virtual void CheckQueue(bool bQWasEmpty) {
        if (bQWasEmpty && get_state() == state::EStateREADY) {
            TriggerNextCommand();
        }
    }
};

using spftp = std::shared_ptr<ftp>;

}

#endif
