#ifndef HTTP_CLIENT_HPP
#define HTTP_CLIENT_HPP

#include <protocol/protocol>

namespace npl {

struct http_message : public message {

    http_message(const std::vector<uint8_t>& m) : message(m) {
        parse_message();
    }

    size_t get_header_count(void) {
        return _headers.size();
    }

    std::string get_header(const std::string& key) {
        return _headers[key];
    }

    void set_header(const std::string& key, const std::string& value) {
        _headers[key] = value;
    }

    virtual size_t get_payload_length(void) override {
        size_t len = 0;
        const auto& h = get_header("Content-Length");
        if (h.size()) {
            len = std::stoi(h);
        }
        return len;
    }

    virtual const char * get_payload_buffer(void) override {
        return get_payload_string().c_str();
    }

    virtual const std::string& get_payload_string(void) override {
        return _payload;
    }

    protected:

    std::string _payload;

    std::map<std::string, std::string> _headers;

    virtual void parse_message() override {
        bool bodyReceived = false;
        bool chunksReceived = false;
        bool headersReceived = false;
        bool firstLineReceived = false;
        if (_data.find("\r\n") != std::string::npos) {
            firstLineReceived = true;
            size_t endofHeaders = _data.find("\r\n\r\n");
            if (endofHeaders != std::string::npos) {
                headersReceived = true;
                if (_data.find("Content-Length") != std::string::npos) {
                    size_t pos = _data.find("Content-Length") + strlen("Content-Length: ");
                    // substring [pos, pos+count)
                    int bodyLength = std::stoi(
                        std::string(_data, pos,
                            _data.find("\r\n", pos) - pos));
                    if (bodyLength) {
                        size_t total = endofHeaders + strlen("\r\n\r\n") + bodyLength;
                        if (_data.size() == total) {
                            bodyReceived = true;
                            _payload = _data.substr(endofHeaders + strlen("\r\n\r\n"), bodyLength);
                        }
                    }
                } else if (_data.find("Transfer-Encoding: chunked") != std::string::npos) {
                    // \r\n\r\n -- endofHeaders
                    // 2e\r\n
                    // {
                    //   chunkLength
                    // }\r\n
                    // 2f\r\n
                    // {
                    //   chunkLength
                    // }\r\n
                    // 0\r\n
                    size_t pos = endofHeaders + strlen("\r\n\r\n");
                    while (_data.find("\r\n", pos) != std::string::npos) {
                        int chunkLength = std::stoi(
                            std::string(_data, pos,
                            _data.find("\r\n", pos) - pos),
                            nullptr, 16);
                        pos = _data.find("\r\n", pos) + strlen("\r\n");
                        if (_data.size() < (pos + chunkLength + strlen("\r\n"))) break;
                        auto chunk = _data.substr(pos, chunkLength);
                        _payload += chunk;
                        if (chunkLength == 0) {
                            chunksReceived = true;
                            break;
                        }
                        pos += chunkLength + strlen("\r\n");
                    }
                } else {
                    LOG << _data;
                    bodyReceived = chunksReceived = true;
                }
            }
        }

        if (firstLineReceived &&
            headersReceived &&
            (bodyReceived || chunksReceived)) {
            std::istringstream ss(
                _data.substr(0, _data.find("\r\n\r\n")));
            std::string line;
            while (std::getline(ss, line, '\n')) {
                line.pop_back();
                size_t index = line.find(": ");
                if (index != std::string::npos) {
                    std::string key, value;
                    key = line.substr(0, index);
                    value = line.substr(index + 2);
                    set_header(key, value);
                }
            }
        }
    }

};

struct http_client : public protocol {

    http_client() = default;
    virtual ~http_client(){};

    void post(const std::string& url, const std::string& body, TListenerOnResponse cbk = {}) {
        std::stringstream req;
        req << "POST " << url << " HTTP/1.1\r\n";
        req << "Host: 127.0.0.1\r\n";
        req << "Content-type: text/plain\r\n";
        req << "Content-length: " << body.size() << "\r\n";
        req << "\r\n";
        req << body;
        setCallback<TListenerOnResponse>(cbk);
        write_async((uint8_t *) req.str().c_str(), req.str().size(), 0);
    }

    protected:

    virtual void state_machine(spmessage m) override {
        protocol::state_machine(m);
    }

    virtual spmessage is_message_complete(const std::vector<uint8_t>& b) override {
        auto m = std::make_shared<http_message>(b);
        if (m->get_header_count()) {
            return m;
        }
        return nullptr;
    }
};

using sphttpclient = std::shared_ptr<http_client>;

}

#endif