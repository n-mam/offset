#ifndef PROTOCOLWS_HPP
#define PROTOCOLWS_HPP

#include <protocol/http>

namespace npl {

struct ws_message : public message {

    ws_message(const uint8_t *b, size_t l) : message(b, l) {
        parse_message();
    }

    uint8_t get_op_code(void) {
        return (_data[0] & 0x0F);
    }

    bool is_control_frame(void) {
        return (get_op_code() & 0x08);
    }

    bool is_masked(void) {
        return (_data[1] & 0x80);
    }

    virtual size_t get_payload_length(void) override {
        return _payload.length();
    }

    virtual const std::string& get_payload_string(void) override {
        return _payload;
    }

    protected:

    std::string _payload;

    virtual void parse_message() override {
        size_t l = _data.size();
        uint8_t *b = (uint8_t *) _data.data();
        assert(l >= 2);
        size_t payloadLength = 0;
        size_t maskingKeyIndex = 0;
        unsigned char indicator = b[1] & 0x7F;
        if (indicator <= 125) {
            /*
             * if 0-125, that is the payload length
             */
            payloadLength = indicator;
            maskingKeyIndex = 2; /** third byte */
        } else if (indicator == 126 && l >= (2 + 2)) {
            /*
             * If 126, the following 2 bytes interpreted as a
             * 16-bit unsigned integer are the payload length
             */
            payloadLength = osl::endian_reverse((uint16_t)(*(b + 2)));
            maskingKeyIndex = 4;
        } else if (indicator == 127 && l >= (2 + 8)) {
            /*
             * If 127, the following 8 bytes interpreted as a
             * 64-bit unsigned integer (the most significant bit
             * MUST be 0) are the payload length
             */
            payloadLength = osl::endian_reverse((uint64_t)(*(b + 2)));
            maskingKeyIndex = 10;
        } else {
            return;
        }
        unsigned char maskingKey[4];
        if (is_masked() && (l >= (maskingKeyIndex + 4))) {
            for (int i = 0; i < 4; i++) {
                maskingKey[i] = b[maskingKeyIndex + i];
            }
        }
        size_t payloadIndex = maskingKeyIndex + (is_masked() ? 4 : 0);
        if ((payloadIndex + payloadLength) == l) {
            for (int i = 0; i < payloadLength; i++) {
                _payload += b[payloadIndex + i] ^ maskingKey[(i % 4)];
            }
        }
    }
};

struct websocket_server : public http_client {

    websocket_server() = default;
    virtual ~websocket_server(){}

    virtual void send_protocol_message(const uint8_t *data, size_t len) override {
        int frameLength = 0;
        unsigned char frame[10];
        /* 1000001 */
        frame[0] = 0x81;
        frameLength++;
        if (len <= 125) {
            frame[1] = (unsigned char) len;
        } else if (len <= 0xFFFF) {
            frame[1] = 126;
            frameLength += 2;
            *((uint16_t *)(frame + 2)) = osl::endian_reverse((uint16_t)len);
        } else if (len >= 65536) {
            frame[1] = 127;
            frameLength += 8;
            *((uint64_t *)(frame + 2)) = osl::endian_reverse((uint64_t)len);
        } else {
            assert(false);
        }
        frameLength++;
        std::string message;
        message.insert(0, (char *) frame, frameLength);
        message.insert(frameLength, (char *) data, len);
        write_async((uint8_t *) message.data(), message.size(), 0);
    }

    protected:

    bool _ws_handshake_done = false;

    virtual void state_machine(spmessage m) override {
        if (!_ws_handshake_done) {
            bool fRet = false;
            auto sock = get_target_socket_device();
            if (sock->is_client_socket()) {
                fRet = validate_server_hello(m);
            } else {
                fRet = validate_client_hello(m);
                if (fRet) {
                    fRet = send_server_hello(m);
                }
            }
            if (fRet) {
                _ws_handshake_done = true;
            }
        } else {
            OnAcceptedClientMessage(shared_from_this(), m->get_payload_string());
        }
    }

    virtual spmessage is_message_complete(const std::vector<uint8_t>& b) override {
        if (_ws_handshake_done) {
            return is_message_complete(b.data(), b.size());
        } else {
            return http_client::is_message_complete(b);
        }
    }

    virtual spmessage is_message_complete(const uint8_t *b, size_t l) {
        if (l < 2) return nullptr;
        auto m = std::make_shared<ws_message>(b, l);
        if (m->get_payload_length()) {
            return m;
        }
        return nullptr;
    }

    virtual bool validate_client_hello(spmessage m) {
        return true; //todo
    }

    virtual bool validate_server_hello(spmessage m) {
        return true; //todo
    }

    virtual bool send_client_hello(void) {
        return false; //todo
    }

    virtual bool send_server_hello(spmessage m) {
        auto cHello = std::dynamic_pointer_cast<http_message>(m);
        auto key = cHello->get_header("Sec-WebSocket-Key");
        assert(key.size());
        key += "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
        unsigned char hash[20] = { '\0' };
        unsigned int hashlen;
        osl::MessageDigest(
            (const unsigned char *) key.c_str(),
            key.size(),
            hash,
            &hashlen);
        unsigned char base64[128] = { '\0' };
        osl::Base64Encode(base64, hash, hashlen);
        std::stringstream sHello;
        sHello << "HTTP/1.1 101 Switching Protocols\r\n";
        sHello << "Upgrade: websocket\r\n";
        sHello << "Connection: Upgrade\r\n";
        sHello << "Sec-WebSocket-Accept: " << base64 << "\r\n";
        sHello << "\r\n";
        write_async((uint8_t *) sHello.str().c_str(), sHello.str().size(), 0);
        return true; //todo
    }

    virtual void onAccept(void *ctx) override {
        auto sock = get_target_socket_device();
        if (sock) {
            auto aso = std::make_shared<websocket_server>();
            aso->setCallback<TListenerOnAcceptedClientMessage>(cbkAcceptedClientmessage);
            sock->get_accepted_client(((context *)ctx)->as)->add_event_listener(aso);
        }
    }

    virtual void onConnect(void) override {
        send_client_hello();
    }
};

using spwsserver = std::shared_ptr<websocket_server>;

}

#endif