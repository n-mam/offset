#ifndef PROTOCOL_HPP
#define PROTOCOL_HPP

#include <device/socket>
#include <osl/osl>

#include <functional>

namespace npl {

struct message {

    message(const std::string& m) {
        _data = m;
    }

    message(const uint8_t *b, size_t l) {
        _data = std::string((char *)b, l);
    }

    message(const std::vector<uint8_t>& m) {
        _data = std::string((char *) m.data(), m.size());
    }

    virtual size_t get_payload_length(void) {
        return _data.size();
    }

    virtual const char * get_payload_buffer(void) {
        return _data.c_str();
    }

    virtual const std::string& get_payload_string(void) {
        return _data;
    }

    protected:

    std::string _data;

    virtual void parse_message(void) { }
};

using spmessage = std::shared_ptr<message>;

struct protocol : public listener {

    using spprotocol = std::shared_ptr<protocol>;

    protocol() = default;
    virtual ~protocol() {}

    virtual size_t get_message_count(void) {
        return _messages.size();
    }

    virtual void start_protocol_server(void) {
        auto sock = get_target_socket_device();
        if (sock) {
            sock->start_socket_server();
        }
    }

    virtual void start_protocol_client(TListenerOnConnect cbk = {}) {
        setCallback<TListenerOnConnect>(cbk);
        auto sock = get_target_socket_device();
        if (sock) {
            sock->start_socket_client();
        }
    }

    virtual void set_credentials(const std::string& user, const std::string& pass) {
        m_user = user;
        m_password = pass;
    }

    virtual void send_protocol_message(const uint8_t *message, size_t len) {
        return;
    }

    virtual tls get_channel_tls() {
        auto sock = get_target_socket_device();
        if (sock) {
            return sock->m_tls;
        }
        return tls::no;
    }

    virtual void set_channel_tls(tls t) {
        auto sock = get_target_socket_device();
        if (sock) {
            sock->m_tls = t;
        }
    }

    virtual bool is_connected(void) override {
        auto sock = get_target_socket_device();
        if (sock) {
            return sock->is_connected() &&
                (get_state() != state::disconnected);
        }
        return false;
    }

    virtual void onRead(const uint8_t *b, size_t n) override {
        for (size_t i = 0; i < n; i++) {
            _buffer.push_back(b[i]);
            auto message = is_message_complete(_buffer);
            if (message) {
                _messages.push_back(message);
                state_machine(message);
                listener::onRead(
                    _buffer.data(),
                    _buffer.size());
                _buffer.clear();
            }
        }
    }

    protected:

    virtual void state_machine(spmessage message) {
        onResponse(message->get_payload_string());
    }

    virtual spmessage is_message_complete(const std::vector<uint8_t>& b) = 0;

    virtual spsocket get_target_socket_device(void) {
        auto target = (this->m_target).lock();
        if (target) {
            return std::static_pointer_cast<socket_device>(target);
        }
        return nullptr;
    }

    std::string m_user;
    std::string m_password;
    std::vector<uint8_t> _buffer;
    std::vector<spmessage> _messages;
};

using spprotocol = std::shared_ptr<protocol>;

}

#endif
