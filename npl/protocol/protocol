#ifndef PROTOCOL_HPP
#define PROTOCOL_HPP

#include <device/socket>
#include <osl/osl>

#include <functional>

namespace npl {

struct message {

    message(const std::string& m) {
        iMessage = m;
    }

    message(const uint8_t *b, size_t l) {
        iMessage = std::string((char *)b, l);
    }

    message(const std::vector<uint8_t>& m) {
        iMessage = std::string((char *) m.data(), m.size());
    }

    virtual size_t get_payload_length(void) {
        return iMessage.size();
    }

    virtual const std::string& get_payload_string(void) {
        return iMessage;
    }

    virtual const char * get_payload_buffer(void) {
        return iMessage.c_str();
    }

    protected:

    std::string iMessage;

    virtual void ParseMessage(void) { }
};

using spmessage = std::shared_ptr<message>;
using TOnUserLoginCbk = std::function<void (bool)>;
using TResponseCbk = std::function<void (const std::string&)>;
using TTransferCbk = std::function<bool (const char *, size_t)>;

template <typename T1, typename T2>
struct protocol : public subject<T1, T2> {

    using spprotocol = std::shared_ptr<protocol<T1, T2>>;
    using TOnConnectCbk = std::function<void (spprotocol, bool)>;
    using TOnClientMessageCbk = std::function<void (spprotocol, const std::string&)>;

    enum : uint8_t {
        EStateConnecting = 0x00,
        EStateConnected = 0x01,
        // protocol specific
        EStateDisconnected = 0xFF
    };

    protocol(){};

    protocol(const std::string& name) : subject<T1, T2>(name) {}

    virtual ~protocol() {}

    virtual void start_protocol_client(TOnConnectCbk cbk = nullptr) {
        iConnectCbk = cbk;
        auto sock = get_target_socket_device();
        if (sock)
        {
            sock->start_socket_client();
        }
    }

    virtual void start_protocol_server(void) {
        auto sock = get_target_socket_device();
        if (sock) {
            sock->start_socket_server();
        }
    }

    virtual size_t get_message_count(void) {
        return iMessages.size();
    }

    virtual void set_credentials(const std::string& user, const std::string& pass, TOnUserLoginCbk cbk = nullptr) {
        m_user = user;
        m_password = pass;
        m_login_callback = cbk;
    }

    virtual void set_response_callback(TResponseCbk cbk) {
        iResponseCallback = cbk;
    }

    virtual void set_client_message_callback(TOnClientMessageCbk cbk) {
        iClientMessageCallback = cbk;
    }

    virtual void send_protocol_message(const uint8_t *message, size_t len) {
        return;
    }

    virtual tls get_channel_tls() {
        auto sock = get_target_socket_device();
        if (sock) {
            return sock->get_tls();
        }
        return tls::no;
    }

    virtual void set_channel_tls(tls t) {
        auto sock = get_target_socket_device();
        if (sock) {
            return sock->set_tls(t);
        }
    }

    virtual bool is_connected(void) override {
        auto sock = get_target_socket_device();
        if (sock) {
            return sock->is_connected() && (iCurrentState != EStateDisconnected);
        }
        return false;
    }

    virtual void onError(uint64_t error) override {
        LOG << "connection error " << error;
    }

    virtual void onConnect(void) override {
        if (iConnectCbk) {
            iConnectCbk(std::static_pointer_cast<protocol<T1, T2>>(this->shared_from_this()), true);
        }
        iCurrentState = EStateConnected;
    }

    virtual void onDisconnect(void) override {
        if (iConnectCbk) {
            iConnectCbk(std::static_pointer_cast<protocol<T1, T2>>(this->shared_from_this()), false);
        }
        iCurrentState = EStateDisconnected;
    }

    virtual void onRead(const T1 *b, size_t n) override {
        for (size_t i = 0; i < n; i++) {
            iBuffer.push_back(b[i]);
            auto message = is_message_complete(iBuffer);
            if (message) {
                iMessages.push_back(message);
                StateMachine(message);
                subject<T1, T2>::onRead(
                    iBuffer.data(),
                    iBuffer.size());
                iBuffer.clear();
            }
        }
    }

    protected:

    virtual spmessage is_message_complete(const std::vector<T1>& b) = 0;

    virtual void StateMachine(spmessage message) { }

    virtual spsocket get_target_socket_device(void) {
        auto target = (this->m_target).lock();
        if (target) {
            return std::static_pointer_cast<socket_device>(target);
        }
        return nullptr;
    }

    std::string m_user;
    std::string m_password;
    std::vector<T1> iBuffer;
    std::vector<spmessage> iMessages;
    TOnConnectCbk iConnectCbk = nullptr;
    uint8_t iCurrentState = EStateConnecting;
    TResponseCbk iResponseCallback = nullptr;
    TOnUserLoginCbk m_login_callback = nullptr;
    TOnClientMessageCbk iClientMessageCallback = nullptr;
};

using spprotocol = std::shared_ptr<protocol<uint8_t, uint8_t>>;
using TOnConnectCbk = std::function<void (spprotocol)>;
using TOnClientMessageCbk = std::function<void (spprotocol, const std::string&)>;

}

#endif
