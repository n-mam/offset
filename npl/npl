#ifndef NPL_HPP
#define NPL_HPP

#include <observer/dispatcher>
#include <device/socket>
#include <protocol/ftp>
#include <protocol/websocket>
#include <singleton>

namespace npl {

inline auto initialize_dispatcher(void) {
    #ifdef _WIN32
    WSADATA wsaData;
    int winsockinit = WSAStartup(MAKEWORD(2, 2), &wsaData);
    #endif
    getSharedInstance<dispatcher>()->initialize_control();
}

inline auto make_ftp(const std::string& host, int port, tls tls = tls::no) {
    SPProtocolFTP ftp;
    auto cc = std::make_shared<socket_device>("sock-cc");
    auto success = cc->set_host_and_port(host, port);
    if (success) {
        cc->m_tls = tls;
        ftp = std::make_shared<npl::ftp>();
        getSharedInstance<dispatcher>()->add_event_listener(cc)->add_event_listener(ftp);
    } else {
        cc.reset();
    }
    return ftp;
}

inline auto make_ws_server(const std::string& host, int port, tls tls,
        TListenerOnAcceptedClientMessage cbk) {
    spwsserver wss;
    auto cc = std::make_shared<socket_device>("ws-cc");
    auto success = cc->set_host_and_port(host, port);
    if (success) {
        cc->m_tls = tls;
        wss = std::make_shared<websocket_server>();
        wss->setCallback<TListenerOnAcceptedClientMessage>(cbk);
        getSharedInstance<dispatcher>()->add_event_listener(cc)->add_event_listener(wss);
    } else {
        cc.reset();
    }
    return wss;
}

inline auto make_http_client(const std::string& host, int port) {
    sphttpclient http;
    auto sock = std::make_shared<socket_device>("http-socket");
    auto success = sock->set_host_and_port(host, port);
    if (success) {
        http = std::make_shared<http_client>();
        getSharedInstance<dispatcher>()->add_event_listener(sock)->add_event_listener(http);
    } else {
        sock.reset();
    }
    return http;
}

template <typename T>
inline auto make_file(const T& path, bool create = false) {
    auto device = std::make_shared<file_device<T>>(path, create);
    if (device->is_open()) {
        getSharedInstance<dispatcher>()->add_event_listener(device);
    } else {
        device.reset();
    }
    return device;
}

inline void test_http_client(const std::string& host, int port) {
    for (int i = 0; i < 1; i++) {
        auto http = npl::make_http_client(host, port);
        http->start_protocol_client({
            [](bool connected) {
                LOG << "client connected : " << connected;
            }});
    }
}

inline void test_ws_server(const std::string& host, int port) {
    auto ws = npl::make_ws_server(host, port, npl::tls::yes,
        {[] (npl::spsubject s, const std::string& m) {
            LOG << "client : " << m;
            auto c = std::dynamic_pointer_cast<protocol>(s);
            c->send_protocol_message(
                (uint8_t *)"server echo : hello",
                strlen("server echo : hello"));
        }});
    ws->start_protocol_server();
    getchar();
}

inline void test_ftp_client(const std::string& host, const std::string& port,
        const std::string& user, const std::string& pass) {
    auto ftp = npl::make_ftp(host, std::stoi(port), npl::tls::yes);
    ftp->set_credentials(user, pass);
    ftp->start_protocol_client();
    ftp->Transfer(ftp::list, "/",
        [list = std::string()] (const char *b, size_t n) mutable {
            if (b) {
                list.append(b, n);
            } else {
                LOG << list;
            }
            return true;
        }, {}, npl::tls::yes);
    ftp->SetCurrentDirectory("/");
    auto file = npl::make_file(TSTR("./xx.txt"), true);
    ftp->Transfer(ftp::download, "x.txt",
        [file, offset = 0ULL](const char *b, size_t n) mutable {
            if (b) {
                file->write_async((uint8_t *)b, n, offset);
                offset += n;
            } else {
                LOG << "Download complete";
            }
            return true;
        }, {}, npl::tls::yes);
    file.reset();
    ftp->Transfer(ftp::upload, "y.txt",
        [&](const char *b, size_t n) mutable {
            return true;
        }, {}, npl::tls::no);
    ftp->write_sync((uint8_t *)"hello ", strlen("hello "));
    ftp->write_sync((uint8_t *)"world ", strlen("world "));
    ftp->write_sync(nullptr);
    ftp->GetCurrentDirectory({
        [](const std::string& resp) {
            //"resp" holds the response of PWD command
        }});
    ftp->SetCurrentDirectory("/");
    ftp->Quit();
    getchar();
}

inline void test_file_copy(const std::string& source, const std::string& dest) {
    auto rd = npl::make_file<std::string>(source);
    auto wd = npl::make_file<std::string>(dest, true);
    constexpr int bufSize = (1 * 1024 * 1024);
    uint8_t *buf = (uint8_t *) calloc(bufSize, 1);
    auto obv = std::make_shared<npl::listener>();
    obv->setCallback<TListenerOnRead>({
        [wd, off = 0ULL](const uint8_t *b, size_t n) mutable {
            DBG << "onRead " << n << ", off " << off;
            if (n) {
                wd->write_async(b, n, off);
            }
            off += n;
        }});
    obv->setCallback<TListenerOnWrite>({
        [rd, off = 0ULL, bufSize](const uint8_t *b, size_t n) mutable {
            DBG << "onWrite " << n << ", off " << off;
            if (n) {
                rd->read_async(b, bufSize, off += n);
            }
        }});
    rd->add_event_listener(obv);
    wd->add_event_listener(obv);
    rd->read_async(buf, bufSize, 0);
    getchar();
}

inline auto usage(void) {
    LOG << " npl http";
    LOG << " npl ftp <host> <port> <user> <pass>";
    LOG << " npl ws";
}

inline void entry(std::vector<std::string> arguments) {
    if (arguments.size() == 1) {
        usage();
        return;
    }
    auto cmd = arguments[1];
    arguments.erase(arguments.begin());
    arguments.erase(arguments.begin());
    if ((cmd == "ftp") && (arguments.size() >= 4)) {
        npl::test_ftp_client(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3]);
    } else if (cmd == "http") {

    } else {
        usage();
    }
}

}

#endif