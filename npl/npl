#ifndef NPL_HPP
#define NPL_HPP

#include <observer/dispatcher>
#include <device/socket>
#include <protocol/ftp>
#include <protocol/websocket>

namespace npl {

SPDispatcher D = nullptr;

auto make_dispatcher(void)
{
  D = std::make_shared<Dispatcher>();
  D->InitializeControl();
  return D;
}

auto make_ftp(const std::string& host, int port, TLS ftps = TLS::No)
{
  auto cc = std::make_shared<SocketDevice>("sock-cc");
  auto ftp = std::make_shared<ProtocolFTP>("protocol-ftp");    

  cc->SetHostAndPort(host, port);

  cc->SetTLS(ftps);

  D->AddEventListener(cc)->AddEventListener(ftp);

  return ftp;
}

auto make_ws_server(const std::string& host, int port, TLS tls = TLS::No, TOnClientMessageCbk cbk = nullptr)
{
  auto cc = std::make_shared<SocketDevice>("ws-cc");
  auto ls = std::make_shared<ProtocolWS>("ws-ls");

  cc->SetTLS(tls);

  cc->SetHostAndPort(host, port);

  ls->SetClientMessageCallback(cbk);

  D->AddEventListener(cc)->AddEventListener(ls);

  return ls;
}

auto make_http_client(const std::string& host, int port)
{
  auto sock = std::make_shared<SocketDevice>("http-socket");
  auto http = std::make_shared<ProtocolHTTP>("http-protocol");    

  sock->SetHostAndPort(host, port);

  D->AddEventListener(sock)->AddEventListener(http);

  return http;
}

template <typename T>
auto make_file(const T& file, bool create = false)
{
  auto device = std::make_shared<FileDevice>(file, create);

  if (device->IsConnected())
  {
    D->AddEventListener(device);
  }
  else
  {
    device.reset();
  }

  return device;
}

void test_http_client(const std::string& host, int port)
{
  for (int i = 0; i < 1; i++)
  {
    auto http = npl::make_http_client(host, port);

    http->StartClient(
      [](auto p)
      {
        LOG << "client connected";
      }
    );
  }
}

void test_ws_server(const std::string& host, int port)
{
  auto ws = npl::make_ws_server(
    host, port, npl::TLS::Yes, 
    [] (npl::SPProtocol c, const std::string& m) 
    {
      LOG << "client : " << m;

      c->SendProtocolMessage(
        (uint8_t *)"server echo : hello", 
        strlen("server echo : hello")
      );
    }
  );

  ws->StartServer();

  getchar();
}

void test_ftp_client(const std::string& host, int port)
{
  auto ftp = npl::make_ftp(host, port, npl::TLS::Yes);

  ftp->SetCredentials("nmam", "welcome123");

  /**
   * asynchronous connect and login sequence
   */
  ftp->StartClient();

  ftp->Transfer(
    ProtocolFTP::EDirection::List,
    "/",
    [list = std::string()] (const char *b, size_t n) mutable {
      if (b) {
        list.append(std::string(b, n));
      } else {
        LOG << list;
      }
      return true;
    },
    npl::TLS::Yes
  );

  ftp->SetCurrentDirectory("/");

  auto file = std::make_shared<FileDevice>(
    "./xx.txt", true);

  ftp->Transfer(ProtocolFTP::EDirection::Download, "x.txt",
      [file, offset = 0](const char *b, size_t n) mutable {
        if (b) {
          file->Write((uint8_t *)b, n, offset);
          offset += n;
        } else {
          LOG << "Download complete";
        }
        return true;
      },
      npl::TLS::Yes);

  file.reset();

  // file = std::make_shared<FileDevice>("./x.txt", true);

  // ftp->Transfer(ProtocolFTP::EDirection::Upload,
  //       "y.txt",
  //       [file, offset = 0](const char *b, size_t n) {
  //         return true;
  //       },
  //       npl::TLS::No);

  // ftp->GetCurrentDirectory([](const std::string& resp) {
  //   /**
  //    * "resp" holds the response of PWD command
  //    */
  // });

  // ftp->SetCurrentDirectory("/");

  ftp->Quit();

  getchar();  
}

void test_file_copy(const std::string& source, const std::string& dest)
{
  auto rd = npl::make_file(source);

  auto wd = npl::make_file(dest, true);

  constexpr int bufSize = (1 * 1024 * 1024);

  uint8_t *buf = (uint8_t *) calloc(bufSize, 1);

  auto obv = std::make_shared<npl::Listener>(
    nullptr,
    [wd, off = 0ULL](const uint8_t *b, size_t n) mutable
    {
      LOG << "onread " << n << ", off " << off;

      if (n)
      {
        wd->Write(b, n, off);
      }

      off += n;
    },
    [rd, off = 0ULL, bufSize](const uint8_t *b, size_t n) mutable
    {
      LOG << "onwrite " << n << ", off " << off;

      if (n)
      {
        rd->Read(b, bufSize, off += n);
      }
    }
  );

  rd->AddEventListener(obv);
  wd->AddEventListener(obv);

  rd->Read(buf, bufSize, 0);

  getchar();
}

void tests_dispatcher()
{
  for (int i = 0; i < 100; i++)
  {
    auto D = std::make_unique<Dispatcher>();
  }

  for (int i = 0; i < 100; i++)
  {
    auto D = std::make_shared<Dispatcher>();
  }

  for (int i = 0; i < 100; i++)
  {
    auto D = new Dispatcher();

    delete D;
  }

  auto D1 = std::make_unique<Dispatcher>();
  auto D2 = std::make_unique<Dispatcher>();
}

auto usage(void)
{
  LOG << " npl -h[ttp] ";
  LOG << " npl -f[tp] <host> <port> <file>";
  LOG << " npl -w[s] ";
}

void entry(std::vector<std::wstring> arguments)
{
  if (arguments.size() == 1)
  {
    usage();
    return;
  }

  auto cmd = arguments[1];

  arguments.erase(arguments.begin());
  arguments.erase(arguments.begin());

  if (cmd == L"-f")
  {
    npl::test_ftp_client(osl::ws2s(arguments[0]), std::stoi(osl::ws2s(arguments[1])));
  }
  else
  {
    usage();
  }  
}

} //namespace npl

#endif