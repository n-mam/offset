#ifndef FILE_HPP
#define FILE_HPP

#include <observer/subject>

#ifdef _WIN32
#include <winsock2.h>
#include <MSWSock.h>
#include <Ws2tcpip.h>
using fd = HANDLE;
#include <osl/fs>
#include <osl/str>
#else
#include <netdb.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
using fd = int;
using SOCKET = int;
#define closesocket close
#define INVALID_HANDLE_VALUE -1
#endif

namespace npl {

enum device {
    none = 0,
    file,
    socket
};

struct context {
    #ifdef _WIN32
    OVERLAPPED ol;
    #endif
    enum {
        read = 0,
        ioctl,
        write,
        accept,
        connect
    } type;
    fd as;
    void *k;
    bool bFree;
    unsigned long n;
    const uint8_t *b;
};


struct file_device : public subject {

    fd _fd_sync = INVALID_HANDLE_VALUE;
    fd _fd_async = INVALID_HANDLE_VALUE;

    file_device() = default;

    template<typename T>
    file_device(const T& path, bool create) {
        #ifdef _WIN32
        if constexpr (std::is_same<T, std::wstring>::value) {
            _fd_async = CreateFileW(
                path.c_str(),
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                (create ? CREATE_ALWAYS : OPEN_EXISTING),
                FILE_FLAG_OVERLAPPED|FILE_FLAG_SEQUENTIAL_SCAN,
                NULL);
        } else if constexpr (std::is_same<T, std::string>::value) {
            _fd_async = CreateFileW(
                osl::utf8_to_win32(path).c_str(),
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                (create ? CREATE_ALWAYS : OPEN_EXISTING),
                FILE_FLAG_OVERLAPPED|FILE_FLAG_SEQUENTIAL_SCAN,
                NULL);
        }
        if (_fd_async == INVALID_HANDLE_VALUE) {
            ERR << path << L", _fd_async CreateFile failed: " << GetLastError();
            return;
        }

        if constexpr (std::is_same<T, std::wstring>::value) {
            _fd_sync = CreateFileW(
                path.c_str(),
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
        } else if constexpr (std::is_same<T, std::string>::value) {
            _fd_sync = CreateFileW(
                osl::utf8_to_win32(path).c_str(),
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
        }
        if (_fd_sync == INVALID_HANDLE_VALUE) {
            ERR << path << L", _fd_sync CreateFile failed: " << GetLastError();
            return;
        }
        #else
        int flags = 0|O_RDWR ;
        if (create) {
            flags |= O_CREAT;
        }
        _fd_async = open(path.c_str(), flags, 0640);
        if (_fd_async < 0) {
            ERR << path << L", error: " << strerror(errno);
            return;
        }
        #endif
        _device_type = device::file;
    }

    virtual ~file_device() {
        if (_device_type == device::file) {
            #ifdef _WIN32
            CloseHandle(_fd_sync);
            CloseHandle(_fd_async);
            #else
            close(_fd_sync);
            close(_fd_async);
            #endif
        }
    }

    auto get_device_type(void) {
        return _device_type;
    }

    bool is_open() {
        return (is_sync_open() && is_async_open());
    }

    bool is_sync_open() {
        return (_fd_sync != INVALID_HANDLE_VALUE);
    }

    bool is_async_open() {
        return (_fd_async != INVALID_HANDLE_VALUE);
    }

    virtual void * read_async(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) override {
        if (!is_async_open()) {
            ERR << name() << " read_async not open";
            return nullptr;
        }
        context *ctx = (context *) calloc(1, sizeof(context));
        ctx->type = context::read;
        if (b) {
            ctx->b = b;
            ctx->bFree = false;
        } else {
            ctx->b = (uint8_t *) calloc(1, DEVICE_BUFFER_SIZE);
            ctx->bFree = true;
            l = DEVICE_BUFFER_SIZE;
        }
        #ifdef _WIN32
        (ctx->ol).Offset = o & 0x00000000FFFFFFFF;
        (ctx->ol).OffsetHigh = (o & 0xFFFFFFFF00000000) >> 32;
        BOOL fRet = ReadFile(_fd_async, (LPVOID) ctx->b, static_cast<DWORD>(l), NULL, &ctx->ol);
        if (!fRet && GetLastError() != ERROR_IO_PENDING) {
            ERR << name() << " ReadFile failed: " << GetLastError();
        }
        return nullptr;
        #else
        ctx->n = read(_fd_async, (void *) ctx->b, l);
        DBG << name() << " read() " << (ssize_t) ctx->n
                << " error : " << strerror(errno);
        if ((ssize_t)ctx->n == -1) {
            if (!b) {
                free ((void *)ctx->b);
            }
            free (ctx), ctx = nullptr;
        }
        return ctx;
        #endif
    }

    virtual bool write_async(const uint8_t *b = nullptr , size_t l = 0, uint64_t o = 0) override {
        if (!is_async_open()) {
            ERR << name() << " write_async not open";
            return false;
        }
        if (!b || !l) {
            ERR << name() << " write_async invalid arguments";
            return false;
        }
        bool fRet = true;
        #ifdef _WIN32
        context *ctx = (context *) calloc(1, sizeof(context));
        ctx->type = context::write;
        ctx->b = (uint8_t *) calloc(l, 1);
        memmove((void *)ctx->b, b, l);
        ctx->bFree = true;
        (ctx->ol).Offset = o & 0x00000000FFFFFFFF;
        (ctx->ol).OffsetHigh = (o & 0xFFFFFFFF00000000) >> 32;
        auto rc = WriteFile(_fd_async, (LPVOID) ctx->b, static_cast<DWORD>(l), NULL, &ctx->ol);
        if (!rc) {
            if ((GetLastError() == ERROR_IO_PENDING)) {
                fRet = true;
            } else {
                ERR << name() << " write_async WriteFile failed: " << GetLastError();
            }
        }
        #else
        auto rc = write(_fd_async, b, l);
        if (rc == -1) {
            ERR << name() << " write_async write failed: " << strerror(errno);
            fRet = false;
        }
        #endif
        return fRet;
    }

    #ifdef _WIN32
    virtual int32_t read_sync(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) override {
        if (!is_sync_open()) {
            ERR << name() << " write_async not open";
            return false;
        }
        DWORD nBytesRead = 0;
        LARGE_INTEGER offset;
        offset.QuadPart = o;
        BOOL fRet = SetFilePointerEx(_fd_sync, offset, NULL, FILE_BEGIN);
        if (fRet) {
            fRet = ReadFile(_fd_sync, (LPVOID) b, static_cast<DWORD>(l), &nBytesRead, NULL);
            if (fRet == FALSE) {
                ERR << name() << " read_sync ReadFile failed: " << GetLastError();
            }
        }
        return nBytesRead;
    }

    virtual int32_t write_sync(const uint8_t *b = nullptr, size_t l = 0, uint64_t o = 0) override {
        if (!is_sync_open()) {
            ERR << name() << " write_async not open";
            return false;
        }
        if (!b || !l) {
            ERR << name() << " write_sync invalid arguments";
            return false;
        }
        DWORD nBytesWritten = 0;
        LARGE_INTEGER offset;
        offset.QuadPart = o;
        BOOL fRet = SetFilePointerEx(_fd_sync, offset, NULL, FILE_BEGIN);
        if (fRet) {
            fRet = WriteFile(_fd_sync, (LPVOID)b, static_cast<DWORD>(l), &nBytesWritten, NULL);
            if (fRet == FALSE) {
                ERR << name() << " write_sync WriteFile failed: " << GetLastError();
            }
        }
        return nBytesWritten;
    }
    #endif

    protected:

    device _device_type = device::none;
    constexpr static uint32_t DEVICE_BUFFER_SIZE = 65536;
};

using spfile = std::shared_ptr<file_device>;

}

#endif